*** RANDOM TEST CARD 1 ***
File 'dominion.c'
Lines executed:85.50% of 614
Branches executed:80.71% of 425
Taken at least once:76.71% of 425
Calls executed:92.63% of 95
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <assert.h>
        -:    5:#include <stdio.h>
        -:    6:#include <math.h>
        -:    7:#include <stdlib.h>
        -:    8:
function compare called 1345966 returned 100% blocks executed 100%
  1345966:    9:int compare(const void* a, const void* b) {
  1345966:   10:  if (*(int*)a > *(int*)b)
branch  0 taken 642135 (fallthrough)
branch  1 taken 703831
   642135:   11:    return 1;
   703831:   12:  if (*(int*)a < *(int*)b)
branch  0 taken 402242 (fallthrough)
branch  1 taken 301589
   402242:   13:    return -1;
   301589:   14:  return 0;
        -:   15:}
        -:   16:
function newGame called 0 returned 0% blocks executed 0%
    #####:   17:struct gameState* newGame() {
    #####:   18:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   19:  return g;
        -:   20:}
        -:   21:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   22:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   23:		  int k8, int k9, int k10) {
    #####:   24:  int* k = malloc(10 * sizeof(int));
    #####:   25:  k[0] = k1;
    #####:   26:  k[1] = k2;
    #####:   27:  k[2] = k3;
    #####:   28:  k[3] = k4;
    #####:   29:  k[4] = k5;
    #####:   30:  k[5] = k6;
    #####:   31:  k[6] = k7;
    #####:   32:  k[7] = k8;
    #####:   33:  k[8] = k9;
    #####:   34:  k[9] = k10;
    #####:   35:  return k;
        -:   36:}
        -:   37:
function initializeGame called 1000 returned 100% blocks executed 95%
     1000:   38:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   39:		   struct gameState *state) {
        -:   40:
        -:   41:  int i;
        -:   42:  int j;
        -:   43:  int it;			
        -:   44:  //set up random number generator
     1000:   45:  SelectStream(1);
call    0 returned 1000
     1000:   46:  PutSeed((long)randomSeed);
call    0 returned 1000
        -:   47:  
        -:   48:  //check number of players
     1000:   49:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 1000 (fallthrough)
branch  1 taken 0
branch  2 taken 356 (fallthrough)
branch  3 taken 644
        -:   50:    {
      356:   51:      return -1;
        -:   52:    }
        -:   53:
        -:   54:  //set number of players
      644:   55:  state->numPlayers = numPlayers;
        -:   56:
        -:   57:  //check selected kingdom cards are different
     7084:   58:  for (i = 0; i < 10; i++)
branch  0 taken 6440
branch  1 taken 644 (fallthrough)
        -:   59:    {
    70840:   60:      for (j = 0; j < 10; j++)
branch  0 taken 64400
branch  1 taken 6440 (fallthrough)
        -:   61:        {
    64400:   62:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 57960 (fallthrough)
branch  1 taken 6440
branch  2 taken 0 (fallthrough)
branch  3 taken 57960
        -:   63:	    {
    #####:   64:	      return -1;
        -:   65:	    }
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:  //initialize supply
        -:   71:  ///////////////////////////////
        -:   72:
        -:   73:  //set number of Curse cards
      644:   74:  if (numPlayers == 2)
branch  0 taken 326 (fallthrough)
branch  1 taken 318
        -:   75:    {
      326:   76:      state->supplyCount[curse] = 10;
        -:   77:    }
      318:   78:  else if (numPlayers == 3)
branch  0 taken 318 (fallthrough)
branch  1 taken 0
        -:   79:    {
      318:   80:      state->supplyCount[curse] = 20;
        -:   81:    }
        -:   82:  else
        -:   83:    {
    #####:   84:      state->supplyCount[curse] = 30;
        -:   85:    }
        -:   86:
        -:   87:  //set number of Victory cards
      644:   88:  if (numPlayers == 2)
branch  0 taken 326 (fallthrough)
branch  1 taken 318
        -:   89:    {
      326:   90:      state->supplyCount[estate] = 8;
      326:   91:      state->supplyCount[duchy] = 8;
      326:   92:      state->supplyCount[province] = 8;
        -:   93:    }
        -:   94:  else
        -:   95:    {
      318:   96:      state->supplyCount[estate] = 12;
      318:   97:      state->supplyCount[duchy] = 12;
      318:   98:      state->supplyCount[province] = 12;
        -:   99:    }
        -:  100:
        -:  101:  //set number of Treasure cards
      644:  102:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      644:  103:  state->supplyCount[silver] = 40;
      644:  104:  state->supplyCount[gold] = 30;
        -:  105:
        -:  106:  //set number of Kingdom cards
    13524:  107:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 12880
branch  1 taken 644 (fallthrough)
        -:  108:    {
   106260:  109:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 99820
branch  1 taken 6440 (fallthrough)
        -:  110:	{
    99820:  111:	  if (kingdomCards[j] == i)
branch  0 taken 6440 (fallthrough)
branch  1 taken 93380
        -:  112:	    {
        -:  113:	      //check if card is a 'Victory' Kingdom card
     6440:  114:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 6440 (fallthrough)
branch  1 taken 0
branch  2 taken 644 (fallthrough)
branch  3 taken 5796
        -:  115:		{
     1288:  116:		  if (numPlayers == 2){ 
branch  0 taken 326 (fallthrough)
branch  1 taken 318
      326:  117:		    state->supplyCount[i] = 8; 
        -:  118:		  }
      318:  119:		  else{ state->supplyCount[i] = 12; }
        -:  120:		}
        -:  121:	      else
        -:  122:		{
     5796:  123:		  state->supplyCount[i] = 10;
        -:  124:		}
     6440:  125:	      break;
        -:  126:	    }
        -:  127:	  else    //card is not in the set choosen for the game
        -:  128:	    {
    93380:  129:	      state->supplyCount[i] = -1;
        -:  130:	    }
        -:  131:	}
        -:  132:
        -:  133:    }
        -:  134:
        -:  135:  ////////////////////////
        -:  136:  //supply intilization complete
        -:  137:
        -:  138:  //set player decks
     2250:  139:  for (i = 0; i < numPlayers; i++)
branch  0 taken 1606
branch  1 taken 644 (fallthrough)
        -:  140:    {
     1606:  141:      state->deckCount[i] = 0;
     6424:  142:      for (j = 0; j < 3; j++)
branch  0 taken 4818
branch  1 taken 1606 (fallthrough)
        -:  143:	{
     4818:  144:	  state->deck[i][j] = estate;
     4818:  145:	  state->deckCount[i]++;
        -:  146:	}
    12848:  147:      for (j = 3; j < 10; j++)
branch  0 taken 11242
branch  1 taken 1606 (fallthrough)
        -:  148:	{
    11242:  149:	  state->deck[i][j] = copper;
    11242:  150:	  state->deckCount[i]++;		
        -:  151:	}
        -:  152:    }
        -:  153:
        -:  154:  //shuffle player decks
     2250:  155:  for (i = 0; i < numPlayers; i++)
branch  0 taken 1606
branch  1 taken 644 (fallthrough)
        -:  156:    {
     1606:  157:      if ( shuffle(i, state) < 0 )
call    0 returned 1606
branch  1 taken 0 (fallthrough)
branch  2 taken 1606
        -:  158:	{
    #####:  159:	  return -1;
        -:  160:	}
        -:  161:    }
        -:  162:
        -:  163:  //draw player hands
     2250:  164:  for (i = 0; i < numPlayers; i++)
branch  0 taken 1606
branch  1 taken 644 (fallthrough)
        -:  165:    {  
        -:  166:      //initialize hand size to zero
     1606:  167:      state->handCount[i] = 0;
     1606:  168:      state->discardCount[i] = 0;
        -:  169:      //draw 5 cards
        -:  170:      // for (j = 0; j < 5; j++)
        -:  171:      //	{
        -:  172:      //	  drawCard(i, state);
        -:  173:      //	}
        -:  174:    }
        -:  175:  
        -:  176:  //set embargo tokens to 0 for all supply piles
    18032:  177:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 17388
branch  1 taken 644 (fallthrough)
        -:  178:    {
    17388:  179:      state->embargoTokens[i] = 0;
        -:  180:    }
        -:  181:
        -:  182:  //initialize first player's turn
      644:  183:  state->outpostPlayed = 0;
      644:  184:  state->phase = 0;
      644:  185:  state->numActions = 1;
      644:  186:  state->numBuys = 1;
      644:  187:  state->playedCardCount = 0;
      644:  188:  state->whoseTurn = 0;
      644:  189:  state->handCount[state->whoseTurn] = 0;
        -:  190:  //int it; move to top
        -:  191:
        -:  192:  //Moved draw cards to here, only drawing at the start of a turn
     3864:  193:  for (it = 0; it < 5; it++){
branch  0 taken 3220
branch  1 taken 644 (fallthrough)
     3220:  194:    drawCard(state->whoseTurn, state);
call    0 returned 3220
        -:  195:  }
        -:  196:
      644:  197:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 644
        -:  198:
      644:  199:  return 0;
        -:  200:}
        -:  201:
function shuffle called 20558 returned 100% blocks executed 100%
    20558:  202:int shuffle(int player, struct gameState *state) {
        -:  203: 
        -:  204:
        -:  205:  int newDeck[MAX_DECK * 2];
    20558:  206:  int newDeckPos = 0;
        -:  207:  int card;
        -:  208:  int i;
        -:  209:
    20558:  210:  if (state->deckCount[player] < 1)
branch  0 taken 846 (fallthrough)
branch  1 taken 19712
      846:  211:    return -1;
    19712:  212:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 19712
        -:  213:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  214:
        -:  215:  //assert(state->deckCount[player] <= MAX_DECK);
   441026:  216:  while (state->deckCount[player] > 0) {
branch  0 taken 401602
branch  1 taken 19712 (fallthrough)
   401602:  217:    card = floor(Random() * state->deckCount[player]);
call    0 returned 401602
   401602:  218:    newDeck[newDeckPos] = state->deck[player][card];
   401602:  219:    newDeckPos++;
  3180540:  220:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 2778938
branch  1 taken 401602 (fallthrough)
  2778938:  221:      state->deck[player][i] = state->deck[player][i+1];
        -:  222:    }
   401602:  223:    state->deckCount[player]--;
        -:  224:  }
   421314:  225:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 401602
branch  1 taken 19712 (fallthrough)
   401602:  226:    state->deck[player][i] = newDeck[i];
   401602:  227:    state->deckCount[player]++;
        -:  228:  }
        -:  229:
    19712:  230:  return 0;
        -:  231:}
        -:  232:
function playCard called 65118 returned 100% blocks executed 100%
    65118:  233:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  234:{	
        -:  235:  int card;
    65118:  236:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  237:
        -:  238:  //check if it is the right phase
    65118:  239:  if (state->phase != 0)
branch  0 taken 8707 (fallthrough)
branch  1 taken 56411
        -:  240:    {
     8707:  241:      return -1;
        -:  242:    }
        -:  243:	
        -:  244:  //check if player has enough actions
    56411:  245:  if ( state->numActions < 1 )
branch  0 taken 10600 (fallthrough)
branch  1 taken 45811
        -:  246:    {
    10600:  247:      return -1;
        -:  248:    }
        -:  249:	
        -:  250:  //get card played
    45811:  251:  card = handCard(handPos, state);
call    0 returned 45811
        -:  252:	
        -:  253:  //check if selected card is an action
    45811:  254:  if ( card < adventurer || card > treasure_map )
branch  0 taken 24698 (fallthrough)
branch  1 taken 21113
branch  2 taken 0 (fallthrough)
branch  3 taken 24698
        -:  255:    {
    21113:  256:      return -1;
        -:  257:    }
        -:  258:	
        -:  259:  //play card
    24698:  260:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 returned 24698
branch  1 taken 6452 (fallthrough)
branch  2 taken 18246
        -:  261:    {
     6452:  262:      return -1;
        -:  263:    }
        -:  264:	
        -:  265:  //reduce number of actions
    18246:  266:  state->numActions--;
        -:  267:
        -:  268:  //update coins (Treasure cards may be added with card draws)
    18246:  269:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 returned 18246
        -:  270:	
    18246:  271:  return 0;
        -:  272:}
        -:  273:
function buyCard called 64906 returned 100% blocks executed 100%
    64906:  274:int buyCard(int supplyPos, struct gameState *state) {
        -:  275:  int who;
        -:  276:  if (DEBUG){
        -:  277:    printf("Entering buyCard...\n");
        -:  278:  }
        -:  279:
        -:  280:  // I don't know what to do about the phase thing.
        -:  281:
    64906:  282:  who = state->whoseTurn;
        -:  283:
    64906:  284:  if (state->numBuys < 1){
branch  0 taken 8061 (fallthrough)
branch  1 taken 56845
        -:  285:    if (DEBUG)
        -:  286:      printf("You do not have any buys left\n");
     8061:  287:    return -1;
    56845:  288:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 56845
branch  1 taken 17142 (fallthrough)
branch  2 taken 39703
        -:  289:    if (DEBUG)
        -:  290:      printf("There are not any of that type of card left\n");
    17142:  291:    return -1;
    39703:  292:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 39703
branch  1 taken 30726 (fallthrough)
branch  2 taken 8977
        -:  293:    if (DEBUG) 
        -:  294:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    30726:  295:    return -1;
        -:  296:  } else {
     8977:  297:    state->phase=1;
        -:  298:    //state->supplyCount[supplyPos]--;
     8977:  299:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 8977
        -:  300:  
     8977:  301:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 8977
     8977:  302:    state->numBuys--;
        -:  303:    if (DEBUG)
        -:  304:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  305:  }
        -:  306:
        -:  307:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  308:  //state->discardCount[who]++;
        -:  309:    
     8977:  310:  return 0;
        -:  311:}
        -:  312:
function numHandCards called 131539 returned 100% blocks executed 100%
   131539:  313:int numHandCards(struct gameState *state) {
   131539:  314:  return state->handCount[ whoseTurn(state) ];
call    0 returned 131539
        -:  315:}
        -:  316:
function handCard called 439241 returned 100% blocks executed 100%
   439241:  317:int handCard(int handPos, struct gameState *state) {
   439241:  318:  int currentPlayer = whoseTurn(state);
call    0 returned 439241
   439241:  319:  return state->hand[currentPlayer][handPos];
        -:  320:}
        -:  321:
function supplyCount called 72161 returned 100% blocks executed 100%
    72161:  322:int supplyCount(int card, struct gameState *state) {
    72161:  323:  return state->supplyCount[card];
        -:  324:}
        -:  325:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  326:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  327:  int i;
    #####:  328:  int count = 0;
        -:  329:
    #####:  330:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  331:    {
    #####:  332:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  333:    }
        -:  334:
    #####:  335:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  336:    {
    #####:  337:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  338:    }
        -:  339:
    #####:  340:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  341:    {
    #####:  342:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  343:    }
        -:  344:
    #####:  345:  return count;
        -:  346:}
        -:  347:
function whoseTurn called 728331 returned 100% blocks executed 100%
   728331:  348:int whoseTurn(struct gameState *state) {
   728331:  349:  return state->whoseTurn;
        -:  350:}
        -:  351:
function endTurn called 64819 returned 100% blocks executed 100%
    64819:  352:int endTurn(struct gameState *state) {
        -:  353:  int k;
        -:  354:  int i;
    64819:  355:  int currentPlayer = whoseTurn(state);
call    0 returned 64819
        -:  356:  
        -:  357:  //Discard hand
   457069:  358:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 392250
branch  1 taken 64819 (fallthrough)
        -:  359:    //assert(state->discardCount[currentPlayer] < MAX_DECK);
   392250:  360:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
   392250:  361:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:  }
    64819:  363:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:    
        -:  365:  //Code for determining the player
    64819:  366:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 37803 (fallthrough)
branch  1 taken 27016
    37803:  367:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:  }
        -:  369:  else{
    27016:  370:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:  }
        -:  372:
    64819:  373:  state->outpostPlayed = 0;
    64819:  374:  state->phase = 0;
    64819:  375:  state->numActions = 1;
    64819:  376:  state->coins = 0;
    64819:  377:  state->numBuys = 1;
    64819:  378:  state->playedCardCount = 0;
    64819:  379:  state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:  //int k; move to top
        -:  382:  //Next player draws hand
   388914:  383:  for (k = 0; k < 5; k++){
branch  0 taken 324095
branch  1 taken 64819 (fallthrough)
   324095:  384:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 324095
        -:  385:  }
        -:  386:
        -:  387:  //Update money
    64819:  388:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 64819
        -:  389:
    64819:  390:  return 0;
        -:  391:}
        -:  392:
function isGameOver called 326213 returned 100% blocks executed 91%
   326213:  393:int isGameOver(struct gameState *state) {
        -:  394:  int i;
        -:  395:  int j;
        -:  396:	
        -:  397:  //if stack of Province cards is empty, the game ends
   326213:  398:  if (state->supplyCount[province] == 0)
branch  0 taken 356 (fallthrough)
branch  1 taken 325857
        -:  399:    {
      356:  400:      return 1;
        -:  401:    }
        -:  402:
        -:  403:  //if three supply pile are at 0, the game ends
   325857:  404:  j = 0;
  8472282:  405:  for (i = 0; i < 25; i++)
branch  0 taken 8146425
branch  1 taken 325857 (fallthrough)
        -:  406:    {
  8146425:  407:      if (state->supplyCount[i] == 0)
branch  0 taken 22836 (fallthrough)
branch  1 taken 8123589
        -:  408:	{
    22836:  409:	  j++;
        -:  410:	}
        -:  411:    }
   325857:  412:  if ( j >= 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 325857
        -:  413:    {
    #####:  414:      return 1;
        -:  415:    }
        -:  416:
   325857:  417:  return 0;
        -:  418:}
        -:  419:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  420:int scoreFor (int player, struct gameState *state) {
        -:  421:
        -:  422:  int i;
    #####:  423:  int score = 0;
        -:  424:  //score from hand
    #####:  425:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  426:    {
    #####:  427:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  430:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  431:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  432:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  433:    }
        -:  434:
        -:  435:  //score from discard
    #####:  436:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  437:    {
    #####:  438:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  441:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  442:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  443:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  444:    }
        -:  445:
        -:  446:  //score from deck
    #####:  447:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  448:    {
    #####:  449:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  452:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  453:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  454:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  455:    }
        -:  456:
    #####:  457:  return score;
        -:  458:}
        -:  459:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:  int i;	
        -:  462:  int j;
        -:  463:  int highScore;
        -:  464:  int currentPlayer;
        -:  465:
        -:  466:  //get score for each player
    #####:  467:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  468:    {
        -:  469:      //set unused player scores to -9999
    #####:  470:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  471:	{
    #####:  472:	  players[i] = -9999;
        -:  473:	}
        -:  474:      else
        -:  475:	{
    #####:  476:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  477:	}
        -:  478:    }
        -:  479:
        -:  480:  //find highest score
    #####:  481:  j = 0;
    #####:  482:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  483:    {
    #####:  484:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  485:	{
    #####:  486:	  j = i;
        -:  487:	}
        -:  488:    }
    #####:  489:  highScore = players[j];
        -:  490:
        -:  491:  //add 1 to players who had less turns
    #####:  492:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  493:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  494:    {
    #####:  495:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  496:	{
    #####:  497:	  players[i]++;
        -:  498:	}
        -:  499:    }
        -:  500:
        -:  501:  //find new highest score
    #####:  502:  j = 0;
    #####:  503:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  504:    {
    #####:  505:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  506:	{
    #####:  507:	  j = i;
        -:  508:	}
        -:  509:    }
    #####:  510:  highScore = players[j];
        -:  511:
        -:  512:  //set winners in array to 1 and rest to 0
    #####:  513:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  514:    {
    #####:  515:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  516:	{
    #####:  517:	  players[i] = 1;
        -:  518:	}
        -:  519:      else
        -:  520:	{
    #####:  521:	  players[i] = 0;
        -:  522:	}
        -:  523:    }
        -:  524:
    #####:  525:  return 0;
        -:  526:}
        -:  527:
function drawCard called 363389 returned 100% blocks executed 100%
   363389:  528:int drawCard(int player, struct gameState *state)
        -:  529:{	int count;
        -:  530:  int deckCounter;
   363389:  531:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 18348 (fallthrough)
branch  1 taken 345041
        -:  532:    
        -:  533:    //Step 1 Shuffle the discard pile back into a deck
        -:  534:    int i;
        -:  535:    //Move discard to deck
   403006:  536:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 384658
branch  1 taken 18348 (fallthrough)
   384658:  537:      state->deck[player][i] = state->discard[player][i];
   384658:  538:      state->discard[player][i] = -1;
        -:  539:    }
        -:  540:
        -:  541:    //assert(state->discardCount[player] <= MAX_DECK);
    18348:  542:    state->deckCount[player] = state->discardCount[player];
    18348:  543:    state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:    //Shufffle the deck
    18348:  546:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 18348
        -:  547:   
        -:  548:    if (DEBUG){//Debug statements
        -:  549:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:    }
        -:  551:    
    18348:  552:    state->discardCount[player] = 0;
        -:  553:
        -:  554:    //Step 2 Draw Card
    18348:  555:    count = state->handCount[player];//Get current player's hand count
        -:  556:    
        -:  557:    if (DEBUG){//Debug statements
        -:  558:      printf("Current hand count: %d\n", count);
        -:  559:    }
        -:  560:    
    18348:  561:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
    18348:  563:    if (deckCounter == 0)
branch  0 taken 326 (fallthrough)
branch  1 taken 18022
      326:  564:      return -1;
        -:  565:
    18022:  566:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    18022:  567:    state->deckCount[player]--;
    18022:  568:    state->handCount[player]++;//Increment hand count
        -:  569:  }
        -:  570:
        -:  571:  else{
   345041:  572:    int count = state->handCount[player];//Get current hand count for player
        -:  573:    int deckCounter;
        -:  574:    if (DEBUG){//Debug statements
        -:  575:      printf("Current hand count: %d\n", count);
        -:  576:    }
        -:  577:
   345041:  578:    deckCounter = state->deckCount[player];//Create holder for the deck count
   345041:  579:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
   345041:  580:    state->deckCount[player]--;
   345041:  581:    state->handCount[player]++;//Increment hand count
        -:  582:  }
        -:  583:
   363063:  584:  return 0;
        -:  585:}
        -:  586:
function getCost called 53835 returned 100% blocks executed 100%
    53835:  587:int getCost(int cardNumber)
        -:  588:{
    53835:  589:  switch( cardNumber ) 
branch  0 taken 6214
branch  1 taken 4485
branch  2 taken 3425
branch  3 taken 3452
branch  4 taken 6792
branch  5 taken 3678
branch  6 taken 2911
branch  7 taken 2961
branch  8 taken 33
branch  9 taken 55
branch 10 taken 3089
branch 11 taken 3041
branch 12 taken 316
branch 13 taken 3155
branch 14 taken 3527
branch 15 taken 58
branch 16 taken 47
branch 17 taken 2938
branch 18 taken 61
branch 19 taken 2971
branch 20 taken 64
branch 21 taken 50
branch 22 taken 49
branch 23 taken 52
branch 24 taken 217
branch 25 taken 76
branch 26 taken 71
branch 27 taken 47
        -:  590:    {
     6214:  591:    case curse:
     6214:  592:      return 0;
     4485:  593:    case estate:
     4485:  594:      return 2;
     3425:  595:    case duchy:
     3425:  596:      return 5;
     3452:  597:    case province:
     3452:  598:      return 8;
     6792:  599:    case copper:
     6792:  600:      return 0;
     3678:  601:    case silver:
     3678:  602:      return 3;
     2911:  603:    case gold:
     2911:  604:      return 6;
     2961:  605:    case adventurer:
     2961:  606:      return 6;
       33:  607:    case council_room:
       33:  608:      return 5;
       55:  609:    case feast:
       55:  610:      return 4;
     3089:  611:    case gardens:
     3089:  612:      return 4;
     3041:  613:    case mine:
     3041:  614:      return 5;
      316:  615:    case remodel:
      316:  616:      return 4;
     3155:  617:    case smithy:
     3155:  618:      return 4;
     3527:  619:    case village:
     3527:  620:      return 3;
       58:  621:    case baron:
       58:  622:      return 4;
       47:  623:    case great_hall:
       47:  624:      return 3;
     2938:  625:    case minion:
     2938:  626:      return 5;
       61:  627:    case steward:
       61:  628:      return 3;
     2971:  629:    case tribute:
     2971:  630:      return 5;
       64:  631:    case ambassador:
       64:  632:      return 3;
       50:  633:    case cutpurse:
       50:  634:      return 4;
       49:  635:    case embargo: 
       49:  636:      return 2;
       52:  637:    case outpost:
       52:  638:      return 5;
      217:  639:    case salvager:
      217:  640:      return 4;
       76:  641:    case sea_hag:
       76:  642:      return 4;
       71:  643:    case treasure_map:
       71:  644:      return 4;
        -:  645:    }
        -:  646:	
       47:  647:  return -1;
        -:  648:}
        -:  649:
function adventurerCardEffect called 1367 returned 100% blocks executed 100%
     1367:  650:int adventurerCardEffect(struct gameState *state, int currentPlayer)
        -:  651:{
     1367:  652:  int drawntreasure = 0;
        -:  653:  int cardDrawn;
     1367:  654:  int z = 0;// this is the counter for the temp hand
        -:  655:  int temphand[MAX_HAND * 2];
        -:  656:
    15640:  657:  while(drawntreasure<2 && z<MAX_HAND){
branch  0 taken 12915 (fallthrough)
branch  1 taken 1358
branch  2 taken 12915
branch  3 taken 0 (fallthrough)
    12915:  658:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 520 (fallthrough)
branch  1 taken 12395
      520:  659:      shuffle(currentPlayer, state);
call    0 returned 520
        -:  660:    }
    12915:  661:    drawCard(currentPlayer, state);
call    0 returned 12915
    12915:  662:    if (state->handCount[currentPlayer] <= 0) {
branch  0 taken 9 (fallthrough)
branch  1 taken 12906
        9:  663:      break;
        -:  664:    }
    12906:  665:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    12906:  666:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 10392 (fallthrough)
branch  1 taken 2514
branch  2 taken 10261 (fallthrough)
branch  3 taken 131
branch  4 taken 71 (fallthrough)
branch  5 taken 10190
     2716:  667:      drawntreasure++;
        -:  668:    else{
    10190:  669:      temphand[z]=cardDrawn;
    10190:  670:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    10190:  671:      z++;
        -:  672:    }
        -:  673:  }
    12924:  674:  while(z-1>=0){
branch  0 taken 10190
branch  1 taken 1367 (fallthrough)
        -:  675:    //assert(state->discardCount[currentPlayer] < MAX_DECK);
    10190:  676:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    10190:  677:    z=z-1;
        -:  678:  }
     1367:  679:  return 0;
        -:  680:}
        -:  681:
function smithyCardEffect called 1109 returned 100% blocks executed 100%
     1109:  682:int smithyCardEffect(struct gameState *state, int handPos, int currentPlayer)
        -:  683:{
        -:  684:  int i;
        -:  685:
        -:  686:  //+3 Cards
     4436:  687:  for (i = 0; i < 3; i++)
branch  0 taken 3327
branch  1 taken 1109 (fallthrough)
        -:  688:    {
     3327:  689:      drawCard(currentPlayer, state);
call    0 returned 3327
        -:  690:    }
        -:  691:
        -:  692:  //discard card from hand
     1109:  693:  discardCard(handPos, currentPlayer, state, 1);
call    0 returned 1109
     1109:  694:  return 0;
        -:  695:}
        -:  696:
function councilRoomCardEffect called 2786 returned 100% blocks executed 100%
     2786:  697:int councilRoomCardEffect(struct gameState *state, int handPos, int currentPlayer)
        -:  698:{
        -:  699:  int i;
        -:  700:
        -:  701:  //+4 Cards
    13930:  702:  for (i = 0; i < 4; i++)
branch  0 taken 11144
branch  1 taken 2786 (fallthrough)
        -:  703:    {
    11144:  704:      drawCard(currentPlayer, state);
call    0 returned 11144
        -:  705:    }
        -:  706:
        -:  707:  //+1 Buy
     2786:  708:  state->numBuys++;
        -:  709:
        -:  710:  //Each other player draws a card
     9711:  711:  for (i = 0; i < state->numPlayers; i++)
branch  0 taken 6925
branch  1 taken 2786 (fallthrough)
        -:  712:    {
     6925:  713:      if ( i != currentPlayer )
branch  0 taken 4139 (fallthrough)
branch  1 taken 2786
        -:  714:        {
     4139:  715:          drawCard(i, state);
call    0 returned 4139
        -:  716:        }
        -:  717:    }
        -:  718:
        -:  719:  //put played card in played card pile
     2786:  720:  discardCard(handPos, currentPlayer, state, 0);
call    0 returned 2786
        -:  721:
     2786:  722:  return 0;
        -:  723:}
        -:  724:
function feastCardEffect called 1318 returned 100% blocks executed 100%
     1318:  725:int feastCardEffect(struct gameState *state, int choice1, int currentPlayer)
        -:  726:{
        -:  727:  int i;
        -:  728:  int x;
        -:  729:  int temphand[MAX_HAND * 2];
        -:  730:
        -:  731:  //gain card with cost up to 5
        -:  732:  //Backup hand
     1318:  733:  int hc = MAX_HAND;
     1318:  734:  if (state->handCount[currentPlayer] < hc) {
branch  0 taken 1318 (fallthrough)
branch  1 taken 0
     1318:  735:    hc = state->handCount[currentPlayer];
        -:  736:  }
     8963:  737:  for (i = 0; i < hc; i++){
branch  0 taken 7645
branch  1 taken 1318 (fallthrough)
     7645:  738:    temphand[i] = state->hand[currentPlayer][i];//Backup card
     7645:  739:    state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  740:  }
        -:  741:  //Backup hand
        -:  742:
        -:  743:  //Update Coins for Buy
     1318:  744:  updateCoins(currentPlayer, state, 5);
call    0 returned 1318
     1318:  745:  x = 1;//Condition to loop on
     3651:  746:  while( x == 1) {//Buy one card
branch  0 taken 1318
branch  1 taken 1015 (fallthrough)
     1318:  747:    if (supplyCount(choice1, state) <= 0){
call    0 returned 1318
branch  1 taken 23 (fallthrough)
branch  2 taken 1295
        -:  748:      if (DEBUG)
        -:  749:        printf("None of that card left, sorry!\n");
        -:  750:
        -:  751:      if (DEBUG){
        -:  752:        printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  753:      }
       23:  754:      return 1;
        -:  755:    }
     1295:  756:    else if (state->coins < getCost(choice1)){
call    0 returned 1295
branch  1 taken 280 (fallthrough)
branch  2 taken 1015
      280:  757:      printf("That card is too expensive!\n");
call    0 returned 280
        -:  758:
        -:  759:      if (DEBUG){
        -:  760:        printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  761:      }
      280:  762:      return 1;
        -:  763:    }
        -:  764:    else{
        -:  765:
        -:  766:      if (DEBUG){
        -:  767:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  768:      }
        -:  769:
     1015:  770:      gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 returned 1015
     1015:  771:      x = 0;//No more buying cards
        -:  772:
        -:  773:      if (DEBUG){
        -:  774:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  775:      }
        -:  776:
        -:  777:    }
        -:  778:  }
        -:  779:
        -:  780:  //Reset Hand
     6817:  781:  for (i = 0; i < hc; i++){
branch  0 taken 5802
branch  1 taken 1015 (fallthrough)
     5802:  782:    state->hand[currentPlayer][i] = temphand[i];
     5802:  783:    temphand[i] = -1;
        -:  784:  }
        -:  785:  //Reset Hand
        -:  786:
     1015:  787:  return 0;
        -:  788:}
        -:  789:
function mineCardEffect called 1592 returned 100% blocks executed 95%
     1592:  790:int mineCardEffect(struct gameState *state, int choice1, int choice2, int handPos, int currentPlayer)
        -:  791:{
        -:  792:  int i;
        -:  793:  int j;
        -:  794:
     1592:  795:  if (choice1 > state->numPlayers) {
branch  0 taken 597 (fallthrough)
branch  1 taken 995
      597:  796:    return -1;
        -:  797:  }
      995:  798:  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  799:
      995:  800:  if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 taken 206 (fallthrough)
branch  1 taken 789
branch  2 taken 123 (fallthrough)
branch  3 taken 83
        -:  801:    {
      912:  802:      return -1;
        -:  803:    }
        -:  804:
       83:  805:  if (choice2 > treasure_map || choice2 < curse)
branch  0 taken 83 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 83
        -:  806:    {
    #####:  807:      return -1;
        -:  808:    }
        -:  809:
       83:  810:  if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 returned 83
call    1 returned 83
branch  2 taken 54 (fallthrough)
branch  3 taken 29
        -:  811:    {
       54:  812:      return -1;
        -:  813:    }
        -:  814:
       29:  815:  gainCard(choice2, state, 2, currentPlayer);
call    0 returned 29
        -:  816:
        -:  817:  //discard card from hand
       29:  818:  discardCard(handPos, currentPlayer, state, 0);
call    0 returned 29
        -:  819:
        -:  820:  //discard trashed card
      117:  821:  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 107
branch  1 taken 10 (fallthrough)
        -:  822:    {
      107:  823:      if (state->hand[currentPlayer][i] == j)
branch  0 taken 19 (fallthrough)
branch  1 taken 88
        -:  824:        {
       19:  825:          discardCard(i, currentPlayer, state, 0);
call    0 returned 19
       19:  826:          break;
        -:  827:        }
        -:  828:    }
        -:  829:
       29:  830:  return 0;
        -:  831:}
        -:  832:
function cardEffect called 24698 returned 100% blocks executed 93%
    24698:  833:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  834:{
        -:  835:  int i;
        -:  836:  int j;
        -:  837:  int k;
        -:  838:  int index;
    24698:  839:  int currentPlayer = whoseTurn(state);
call    0 returned 24698
    24698:  840:  int nextPlayer = currentPlayer + 1;
        -:  841:
    24698:  842:  int tributeRevealedCards[2] = {-1, -1};
    24698:  843:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 taken 10304 (fallthrough)
branch  1 taken 14394
    10304:  844:    nextPlayer = 0;
        -:  845:  }
        -:  846:  
        -:  847:	
        -:  848:  //uses switch to select card and perform actions
    24698:  849:  switch( card ) 
branch  0 taken 1367
branch  1 taken 271
branch  2 taken 1318
branch  3 taken 1618
branch  4 taken 1592
branch  5 taken 1384
branch  6 taken 1109
branch  7 taken 1340
branch  8 taken 1387
branch  9 taken 1045
branch 10 taken 1093
branch 11 taken 1128
branch 12 taken 1669
branch 13 taken 1444
branch 14 taken 1038
branch 15 taken 1004
branch 16 taken 1049
branch 17 taken 1116
branch 18 taken 1410
branch 19 taken 1316
branch 20 taken 0
        -:  850:    {
     1367:  851:    case adventurer:
     1367:  852:      return adventurerCardEffect(state, currentPlayer);
call    0 returned 1367
        -:  853:			
      271:  854:    case council_room:
      271:  855:      return councilRoomCardEffect(state, handPos, currentPlayer);
call    0 returned 271
        -:  856:			
     1318:  857:    case feast:
     1318:  858:      return feastCardEffect(state, choice1, currentPlayer);
call    0 returned 1318
        -:  859:			
     1618:  860:    case gardens:
     1618:  861:      return -1;
        -:  862:			
     1592:  863:    case mine:
     1592:  864:      return mineCardEffect(state, choice1, choice2, currentPlayer, handPos);
call    0 returned 1592
        -:  865:			
     1384:  866:    case remodel:
     1384:  867:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  868:
     1384:  869:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 returned 1384
call    1 returned 1384
branch  2 taken 900 (fallthrough)
branch  3 taken 484
        -:  870:	{
      900:  871:	  return -1;
        -:  872:	}
        -:  873:
      484:  874:      gainCard(choice2, state, 0, currentPlayer);
call    0 returned 484
        -:  875:
        -:  876:      //discard card from hand
      484:  877:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 484
        -:  878:
        -:  879:      //discard trashed card
     1328:  880:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 1281
branch  1 taken 47 (fallthrough)
        -:  881:	{
     1281:  882:	  if (state->hand[currentPlayer][i] == j)
branch  0 taken 437 (fallthrough)
branch  1 taken 844
        -:  883:	    {
      437:  884:	      discardCard(i, currentPlayer, state, 0);			
call    0 returned 437
      437:  885:	      break;
        -:  886:	    }
        -:  887:	}
        -:  888:
        -:  889:
      484:  890:      return 0;
        -:  891:		
     1109:  892:    case smithy:
     1109:  893:      return smithyCardEffect(state, handPos, currentPlayer);
call    0 returned 1109
        -:  894:		
     1340:  895:    case village:
        -:  896:      //+1 Card
     1340:  897:      drawCard(currentPlayer, state);
call    0 returned 1340
        -:  898:			
        -:  899:      //+2 Actions
     1340:  900:      state->numActions = state->numActions + 2;
        -:  901:			
        -:  902:      //discard played card from hand
     1340:  903:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 1340
     1340:  904:      return 0;
        -:  905:		
     1387:  906:    case baron:
     1387:  907:      state->numBuys++;//Increase buys by 1!
     1387:  908:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 taken 1139 (fallthrough)
branch  1 taken 248
     1139:  909:	int p = 0;//Iterator for hand!
     1139:  910:	int card_not_discarded = 1;//Flag for discard set!
     8837:  911:	while(card_not_discarded){
branch  0 taken 6559
branch  1 taken 1139 (fallthrough)
     6559:  912:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 taken 480 (fallthrough)
branch  1 taken 6079
      480:  913:	    state->coins += 4;//Add 4 coins to the amount of coins
        -:  914:	    //assert(state->discardCount[currentPlayer] < MAX_DECK);
      480:  915:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
      480:  916:	    state->discardCount[currentPlayer]++;
     2479:  917:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 taken 1999
branch  1 taken 480 (fallthrough)
     1999:  918:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  919:	    }
      480:  920:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
      480:  921:	    state->handCount[currentPlayer]--;
      480:  922:	    card_not_discarded = 0;//Exit the loop
        -:  923:	  }
     6079:  924:	  else if (p > state->handCount[currentPlayer]){
branch  0 taken 659 (fallthrough)
branch  1 taken 5420
        -:  925:	    if(DEBUG) {
        -:  926:	      printf("No estate cards in your hand, invalid choice\n");
        -:  927:	      printf("Must gain an estate if there are any\n");
        -:  928:	    }
      659:  929:	    if (supplyCount(estate, state) > 0){
call    0 returned 659
branch  1 taken 553 (fallthrough)
branch  2 taken 106
      553:  930:	      gainCard(estate, state, 0, currentPlayer);
call    0 returned 553
      553:  931:	      state->supplyCount[estate]--;//Decrement estates
      553:  932:	      if (supplyCount(estate, state) == 0){
call    0 returned 553
branch  1 taken 33 (fallthrough)
branch  2 taken 520
       33:  933:		isGameOver(state);
call    0 returned 33
        -:  934:	      }
        -:  935:	    }
      659:  936:	    card_not_discarded = 0;//Exit the loop
        -:  937:	  }
        -:  938:			    
        -:  939:	  else{
     5420:  940:	    p++;//Next card
        -:  941:	  }
        -:  942:	}
        -:  943:      }
        -:  944:			    
        -:  945:      else{
      248:  946:	if (supplyCount(estate, state) > 0){
call    0 returned 248
branch  1 taken 220 (fallthrough)
branch  2 taken 28
      220:  947:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 returned 220
      220:  948:	  state->supplyCount[estate]--;//Decrement Estates
      220:  949:	  if (supplyCount(estate, state) == 0){
call    0 returned 220
branch  1 taken 14 (fallthrough)
branch  2 taken 206
       14:  950:	    isGameOver(state);
call    0 returned 14
        -:  951:	  }
        -:  952:	}
        -:  953:      }
        -:  954:	    
        -:  955:      
     1387:  956:      return 0;
        -:  957:		
     1045:  958:    case great_hall:
        -:  959:      //+1 Card
     1045:  960:      drawCard(currentPlayer, state);
call    0 returned 1045
        -:  961:			
        -:  962:      //+1 Actions
     1045:  963:      state->numActions++;
        -:  964:			
        -:  965:      //discard card from hand
     1045:  966:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 1045
     1045:  967:      return 0;
        -:  968:		
     1093:  969:    case minion:
        -:  970:      //+1 action
     1093:  971:      state->numActions++;
        -:  972:			
        -:  973:      //discard card from hand
     1093:  974:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 1093
        -:  975:			
     1093:  976:      if (choice1)		//+2 coins
branch  0 taken 888 (fallthrough)
branch  1 taken 205
        -:  977:	{
      888:  978:	  state->coins = state->coins + 2;
        -:  979:	}
        -:  980:			
      205:  981:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 taken 174 (fallthrough)
branch  1 taken 31
        -:  982:	{
        -:  983:	  //discard hand
     1147:  984:	  while(numHandCards(state) > 0)
call    0 returned 973
branch  1 taken 799
branch  2 taken 174 (fallthrough)
        -:  985:	    {
      799:  986:	      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 799
        -:  987:	    }
        -:  988:				
        -:  989:	  //draw 4
      870:  990:	  for (i = 0; i < 4; i++)
branch  0 taken 696
branch  1 taken 174 (fallthrough)
        -:  991:	    {
      696:  992:	      drawCard(currentPlayer, state);
call    0 returned 696
        -:  993:	    }
        -:  994:				
        -:  995:	  //other players discard hand and redraw if hand size > 4
      605:  996:	  for (i = 0; i < state->numPlayers; i++)
branch  0 taken 431
branch  1 taken 174 (fallthrough)
        -:  997:	    {
      431:  998:	      if (i != currentPlayer)
branch  0 taken 257 (fallthrough)
branch  1 taken 174
        -:  999:		{
      257: 1000:		  if ( state->handCount[i] > 4 )
branch  0 taken 0 (fallthrough)
branch  1 taken 257
        -: 1001:		    {
        -: 1002:		      //discard hand
    #####: 1003:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1004:			{
    #####: 1005:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1006:			}
        -: 1007:							
        -: 1008:		      //draw 4
    #####: 1009:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1010:			{
    #####: 1011:			  drawCard(i, state);
call    0 never executed
        -: 1012:			}
        -: 1013:		    }
        -: 1014:		}
        -: 1015:	    }
        -: 1016:				
        -: 1017:	}
     1093: 1018:      return 0;
        -: 1019:		
     1128: 1020:    case steward:
     1128: 1021:      if (choice1 == 1)
branch  0 taken 214 (fallthrough)
branch  1 taken 914
        -: 1022:	{
        -: 1023:	  //+2 cards
      214: 1024:	  drawCard(currentPlayer, state);
call    0 returned 214
      214: 1025:	  drawCard(currentPlayer, state);
call    0 returned 214
        -: 1026:	}
      914: 1027:      else if (choice1 == 2)
branch  0 taken 211 (fallthrough)
branch  1 taken 703
        -: 1028:	{
        -: 1029:	  //+2 coins
      211: 1030:	  state->coins = state->coins + 2;
        -: 1031:	}
        -: 1032:      else
        -: 1033:	{
        -: 1034:	  //trash 2 cards in hand
      703: 1035:	  discardCard(choice2, currentPlayer, state, 1);
call    0 returned 703
      703: 1036:	  discardCard(choice3, currentPlayer, state, 1);
call    0 returned 703
        -: 1037:	}
        -: 1038:			
        -: 1039:      //discard card from hand
     1128: 1040:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 1128
     1128: 1041:      return 0;
        -: 1042:		
     1669: 1043:    case tribute:
     1669: 1044:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 taken 1 (fallthrough)
branch  1 taken 1668
        1: 1045:	if (state->deckCount[nextPlayer] > 0){
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1046:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1047:	  state->deckCount[nextPlayer]--;
        -: 1048:	}
        1: 1049:	else if (state->discardCount[nextPlayer] > 0){
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1050:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1051:	  state->discardCount[nextPlayer]--;
        -: 1052:	}
        -: 1053:	else{
        -: 1054:	  //No Card to Reveal
        -: 1055:	  if (DEBUG){
        -: 1056:	    printf("No cards to reveal\n");
        -: 1057:	  }
        -: 1058:	}
        -: 1059:      }
        -: 1060:	    
        -: 1061:      else{
     1668: 1062:	if (state->deckCount[nextPlayer] == 0){
branch  0 taken 84 (fallthrough)
branch  1 taken 1584
      968: 1063:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 taken 884
branch  1 taken 84 (fallthrough)
      884: 1064:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
        -: 1065:	    //assert(state->deckCount[nextPlayer] < MAX_DECK);
      884: 1066:	    state->deckCount[nextPlayer]++;
      884: 1067:	    state->discard[nextPlayer][i] = -1;
      884: 1068:	    state->discardCount[nextPlayer]--;
        -: 1069:	  }
        -: 1070:			    
       84: 1071:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 returned 84
        -: 1072:	} 
     1668: 1073:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
     1668: 1074:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
     1668: 1075:	state->deckCount[nextPlayer]--;
     1668: 1076:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
     1668: 1077:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
     1668: 1078:	state->deckCount[nextPlayer]--;
        -: 1079:      }    
        -: 1080:		       
     1669: 1081:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 taken 195 (fallthrough)
branch  1 taken 1474
      195: 1082:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
      195: 1083:	state->playedCardCount++;
      195: 1084:	tributeRevealedCards[1] = -1;
        -: 1085:      }
        -: 1086:
     6676: 1087:      for (i = 0; i <= 2; i ++){
branch  0 taken 5007
branch  1 taken 1669 (fallthrough)
     5007: 1088:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 taken 4391 (fallthrough)
branch  1 taken 616
branch  2 taken 4359 (fallthrough)
branch  3 taken 32
branch  4 taken 32 (fallthrough)
branch  5 taken 4327
      680: 1089:	  state->coins += 2;
        -: 1090:	}
        -: 1091:		    
     4327: 1092:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 taken 4010 (fallthrough)
branch  1 taken 317
branch  2 taken 3997 (fallthrough)
branch  3 taken 13
branch  4 taken 3989 (fallthrough)
branch  5 taken 8
branch  6 taken 3890 (fallthrough)
branch  7 taken 99
branch  8 taken 83 (fallthrough)
branch  9 taken 3807
      520: 1093:	  drawCard(currentPlayer, state);
call    0 returned 520
      520: 1094:	  drawCard(currentPlayer, state);
call    0 returned 520
        -: 1095:	}
        -: 1096:	else{//Action Card
     3807: 1097:	  state->numActions = state->numActions + 2;
        -: 1098:	}
        -: 1099:      }
        -: 1100:	    
     1669: 1101:      return 0;
        -: 1102:		
     1444: 1103:    case ambassador:
     1444: 1104:      j = 0;		//used to check if player has enough cards to discard
        -: 1105:
     1444: 1106:      if (choice2 > 2 || choice2 < 0)
branch  0 taken 731 (fallthrough)
branch  1 taken 713
branch  2 taken 0 (fallthrough)
branch  3 taken 731
        -: 1107:	{
      713: 1108:	  return -1;				
        -: 1109:	}
        -: 1110:
      731: 1111:      if (choice1 == handPos)
branch  0 taken 137 (fallthrough)
branch  1 taken 594
        -: 1112:	{
      137: 1113:	  return -1;
        -: 1114:	}
        -: 1115:
     3970: 1116:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 3376
branch  1 taken 594 (fallthrough)
        -: 1117:	{
     3376: 1118:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 taken 2782 (fallthrough)
branch  1 taken 594
branch  2 taken 151 (fallthrough)
branch  3 taken 2631
branch  4 taken 113 (fallthrough)
branch  5 taken 38
        -: 1119:	    {
      113: 1120:	      j++;
        -: 1121:	    }
        -: 1122:	}
      594: 1123:      if (j < choice2)
branch  0 taken 360 (fallthrough)
branch  1 taken 234
        -: 1124:	{
      360: 1125:	  return -1;				
        -: 1126:	}
        -: 1127:
        -: 1128:      if (DEBUG) 
        -: 1129:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1130:
        -: 1131:      //increase supply count for choosen card by amount being discarded
      234: 1132:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1133:			
        -: 1134:      //each other player gains a copy of revealed card
      825: 1135:      for (i = 0; i < state->numPlayers; i++)
branch  0 taken 591
branch  1 taken 234 (fallthrough)
        -: 1136:	{
      591: 1137:	  if (i != currentPlayer)
branch  0 taken 360 (fallthrough)
branch  1 taken 231
        -: 1138:	    {
      360: 1139:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 returned 360
        -: 1140:	    }
        -: 1141:	}
        -: 1142:
        -: 1143:      //discard played card from hand
      234: 1144:      discardCard(handPos, currentPlayer, state, 0);			
call    0 returned 234
        -: 1145:
        -: 1146:      //trash copies of cards returned to supply
      278: 1147:      for (j = 0; j < choice2; j++)
branch  0 taken 44
branch  1 taken 234 (fallthrough)
        -: 1148:	{
      106: 1149:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 101
branch  1 taken 5 (fallthrough)
        -: 1150:	    {
      101: 1151:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 taken 39 (fallthrough)
branch  1 taken 62
        -: 1152:		{
       39: 1153:		  discardCard(i, currentPlayer, state, 1);
call    0 returned 39
       39: 1154:		  break;
        -: 1155:		}
        -: 1156:	    }
        -: 1157:	}			
        -: 1158:
      234: 1159:      return 0;
        -: 1160:		
     1038: 1161:    case cutpurse:
        -: 1162:
     1038: 1163:      updateCoins(currentPlayer, state, 2);
call    0 returned 1038
     3612: 1164:      for (i = 0; i < state->numPlayers; i++)
branch  0 taken 2574
branch  1 taken 1038 (fallthrough)
        -: 1165:	{
     2574: 1166:	  if (i != currentPlayer)
branch  0 taken 1536 (fallthrough)
branch  1 taken 1038
        -: 1167:	    {
     1574: 1168:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 taken 55
branch  1 taken 1519 (fallthrough)
        -: 1169:		{
       55: 1170:		  if (state->hand[i][j] == copper)
branch  0 taken 17 (fallthrough)
branch  1 taken 38
        -: 1171:		    {
       17: 1172:		      discardCard(j, i, state, 0);
call    0 returned 17
       17: 1173:		      break;
        -: 1174:		    }
       38: 1175:		  if (j == state->handCount[i])
branch  0 taken 0 (fallthrough)
branch  1 taken 38
        -: 1176:		    {
    #####: 1177:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1178:			{
        -: 1179:			  if (DEBUG)
        -: 1180:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1181:			}	
    #####: 1182:		      break;
        -: 1183:		    }		
        -: 1184:		}
        -: 1185:					
        -: 1186:	    }
        -: 1187:				
        -: 1188:	}				
        -: 1189:
        -: 1190:      //discard played card from hand
     1038: 1191:      discardCard(handPos, currentPlayer, state, 0);			
call    0 returned 1038
        -: 1192:
     1038: 1193:      return 0;
        -: 1194:
        -: 1195:		
     1004: 1196:    case embargo: 
        -: 1197:      //+2 Coins
     1004: 1198:      state->coins = state->coins + 2;
        -: 1199:			
        -: 1200:      //see if selected pile is in play
     1004: 1201:      if ( state->supplyCount[choice1] == -1 )
branch  0 taken 15 (fallthrough)
branch  1 taken 989
        -: 1202:	{
       15: 1203:	  return -1;
        -: 1204:	}
        -: 1205:			
        -: 1206:      //add embargo token to selected supply pile
      989: 1207:      state->embargoTokens[choice1]++;
        -: 1208:			
        -: 1209:      //trash card
      989: 1210:      discardCard(handPos, currentPlayer, state, 1);		
call    0 returned 989
      989: 1211:      return 0;
        -: 1212:		
     1049: 1213:    case outpost:
        -: 1214:      //set outpost flag
     1049: 1215:      state->outpostPlayed++;
        -: 1216:			
        -: 1217:      //discard card
     1049: 1218:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 1049
     1049: 1219:      return 0;
        -: 1220:		
     1116: 1221:    case salvager:
        -: 1222:      //+1 buy
     1116: 1223:      state->numBuys++;
        -: 1224:			
     1116: 1225:      if (choice1)
branch  0 taken 926 (fallthrough)
branch  1 taken 190
        -: 1226:	{
        -: 1227:	  //gain coins equal to trashed card
      926: 1228:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 returned 926
call    1 returned 926
        -: 1229:	  //trash card
      926: 1230:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 returned 926
        -: 1231:	}
        -: 1232:			
        -: 1233:      //discard card
     1116: 1234:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 1116
     1116: 1235:      return 0;
        -: 1236:		
     1410: 1237:    case sea_hag:
     4889: 1238:      for (i = 0; i < state->numPlayers; i++){
branch  0 taken 3479
branch  1 taken 1410 (fallthrough)
     3479: 1239:	if (i != currentPlayer){
branch  0 taken 2069 (fallthrough)
branch  1 taken 1410
        -: 1240:          //assert(state->deckCount[i] > 0);
        -: 1241:	  //assert(state->discardCount < MAX_DECK);
     2069: 1242:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
     2069: 1243:	  state->discardCount[i]++;
     2069: 1244:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1245:	}
        -: 1246:      }
     1410: 1247:      return 0;
        -: 1248:		
     1316: 1249:    case treasure_map:
        -: 1250:      //search hand for another treasure_map
     1316: 1251:      index = -1;
     8395: 1252:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 7249
branch  1 taken 1146 (fallthrough)
        -: 1253:	{
     7249: 1254:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 taken 1398 (fallthrough)
branch  1 taken 5851
branch  2 taken 170 (fallthrough)
branch  3 taken 1228
        -: 1255:	    {
      170: 1256:	      index = i;
      170: 1257:	      break;
        -: 1258:	    }
        -: 1259:	}
     1316: 1260:      if (index > -1)
branch  0 taken 170 (fallthrough)
branch  1 taken 1146
        -: 1261:	{
        -: 1262:	  //trash both treasure cards
      170: 1263:	  discardCard(handPos, currentPlayer, state, 1);
call    0 returned 170
      170: 1264:	  discardCard(index, currentPlayer, state, 1);
call    0 returned 170
        -: 1265:
        -: 1266:	  //gain 4 Gold cards
      850: 1267:	  for (i = 0; i < 4; i++)
branch  0 taken 680
branch  1 taken 170 (fallthrough)
        -: 1268:	    {
      680: 1269:	      gainCard(gold, state, 1, currentPlayer);
call    0 returned 680
        -: 1270:	    }
        -: 1271:				
        -: 1272:	  //return success
      170: 1273:	  return 1;
        -: 1274:	}
        -: 1275:			
        -: 1276:      //no second treasure_map found in hand
     1146: 1277:      return -1;
        -: 1278:    }
        -: 1279:	
    #####: 1280:  return -1;
        -: 1281:}
        -: 1282:
function discardCard called 17423 returned 100% blocks executed 100%
    17423: 1283:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1284:{
        -: 1285:	
        -: 1286:  //if card is not trashed, added to Played pile 
    17423: 1287:  if (trashFlag < 1)
branch  0 taken 12614 (fallthrough)
branch  1 taken 4809
        -: 1288:    {
        -: 1289:      //add card to played pile
    12614: 1290:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    12614: 1291:      state->playedCardCount++;
        -: 1292:    }
        -: 1293:	
        -: 1294:  //set played card to -1
    17423: 1295:  state->hand[currentPlayer][handPos] = -1;
        -: 1296:	
        -: 1297:  //remove card from player's hand
    17423: 1298:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 2211 (fallthrough)
branch  1 taken 15212
        -: 1299:    {
        -: 1300:      //reduce number of cards in hand
     2211: 1301:      state->handCount[currentPlayer]--;
        -: 1302:    }
    15212: 1303:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 149 (fallthrough)
branch  1 taken 15063
        -: 1304:    {
        -: 1305:      //reduce number of cards in hand
      149: 1306:      state->handCount[currentPlayer]--;
        -: 1307:    }
        -: 1308:  else 	
        -: 1309:    {
        -: 1310:      //replace discarded card with last card in hand
    15063: 1311:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1312:      //set last card to -1
    15063: 1313:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1314:      //reduce number of cards in hand
    15063: 1315:      state->handCount[currentPlayer]--;
        -: 1316:    }
        -: 1317:	
    17423: 1318:  return 0;
        -: 1319:}
        -: 1320:
function gainCard called 12318 returned 100% blocks executed 100%
    12318: 1321:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1322:{
        -: 1323:  //Note: supplyPos is enum of choosen card
        -: 1324:	
        -: 1325:  //check if supply pile is empty (0) or card is not used in game (-1)
    12318: 1326:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 12318
branch  1 taken 85 (fallthrough)
branch  2 taken 12233
        -: 1327:    {
       85: 1328:      return -1;
        -: 1329:    }
        -: 1330:	
        -: 1331:  //added card for [whoseTurn] current player:
        -: 1332:  // toFlag = 0 : add to discard
        -: 1333:  // toFlag = 1 : add to deck
        -: 1334:  // toFlag = 2 : add to hand
        -: 1335:
    12233: 1336:  if (toFlag == 1)
branch  0 taken 680 (fallthrough)
branch  1 taken 11553
        -: 1337:    {
        -: 1338:      //assert(state->deckCount[player] < MAX_DECK);
      680: 1339:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
      680: 1340:      state->deckCount[player]++;
        -: 1341:    }
    11553: 1342:  else if (toFlag == 2)
branch  0 taken 29 (fallthrough)
branch  1 taken 11524
        -: 1343:    {
       29: 1344:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
       29: 1345:      state->handCount[player]++;
        -: 1346:    }
        -: 1347:  else
        -: 1348:    {
        -: 1349:      //assert(state->discardCount[player] < MAX_DECK);
    11524: 1350:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    11524: 1351:      state->discardCount[player]++;
        -: 1352:    }
        -: 1353:	
        -: 1354:  //decrease number in supply pile
    12233: 1355:  state->supplyCount[supplyPos]--;
        -: 1356:	 
    12233: 1357:  return 0;
        -: 1358:}
        -: 1359:
function updateCoins called 86065 returned 100% blocks executed 100%
    86065: 1360:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1361:{
        -: 1362:  int i;
        -: 1363:	
        -: 1364:  //reset coin count
    86065: 1365:  state->coins = 0;
        -: 1366:
        -: 1367:  //add coins for each Treasure card in player's hand
   530226: 1368:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 444161
branch  1 taken 86065 (fallthrough)
        -: 1369:    {
   444161: 1370:      if (state->hand[player][i] == copper)
branch  0 taken 115277 (fallthrough)
branch  1 taken 328884
        -: 1371:	{
   115277: 1372:	  state->coins += 1;
        -: 1373:	}
   328884: 1374:      else if (state->hand[player][i] == silver)
branch  0 taken 3900 (fallthrough)
branch  1 taken 324984
        -: 1375:	{
     3900: 1376:	  state->coins += 2;
        -: 1377:	}
   324984: 1378:      else if (state->hand[player][i] == gold)
branch  0 taken 2600 (fallthrough)
branch  1 taken 322384
        -: 1379:	{
     2600: 1380:	  state->coins += 3;
        -: 1381:	}	
        -: 1382:    }	
        -: 1383:
        -: 1384:  //add bonus
    86065: 1385:  state->coins += bonus;
        -: 1386:
    86065: 1387:  return 0;
        -: 1388:}
        -: 1389:
        -: 1390:
        -: 1391://end of dominion.c
        -: 1392:
*** RANDOM TEST CARD 2 ***
File 'dominion.c'
Lines executed:85.50% of 614
Branches executed:80.71% of 425
Taken at least once:76.71% of 425
Calls executed:92.63% of 95
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:2
        -:    0:Programs:2
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <assert.h>
        -:    5:#include <stdio.h>
        -:    6:#include <math.h>
        -:    7:#include <stdlib.h>
        -:    8:
function compare called 2785703 returned 100% blocks executed 100%
  2785703:    9:int compare(const void* a, const void* b) {
  2785703:   10:  if (*(int*)a > *(int*)b)
branch  0 taken 1326655 (fallthrough)
branch  1 taken 1459048
  1326655:   11:    return 1;
  1459048:   12:  if (*(int*)a < *(int*)b)
branch  0 taken 803343 (fallthrough)
branch  1 taken 655705
   803343:   13:    return -1;
   655705:   14:  return 0;
        -:   15:}
        -:   16:
function newGame called 0 returned 0% blocks executed 0%
    #####:   17:struct gameState* newGame() {
    #####:   18:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   19:  return g;
        -:   20:}
        -:   21:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   22:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   23:		  int k8, int k9, int k10) {
    #####:   24:  int* k = malloc(10 * sizeof(int));
    #####:   25:  k[0] = k1;
    #####:   26:  k[1] = k2;
    #####:   27:  k[2] = k3;
    #####:   28:  k[3] = k4;
    #####:   29:  k[4] = k5;
    #####:   30:  k[5] = k6;
    #####:   31:  k[6] = k7;
    #####:   32:  k[7] = k8;
    #####:   33:  k[8] = k9;
    #####:   34:  k[9] = k10;
    #####:   35:  return k;
        -:   36:}
        -:   37:
function initializeGame called 2000 returned 100% blocks executed 95%
     2000:   38:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   39:		   struct gameState *state) {
        -:   40:
        -:   41:  int i;
        -:   42:  int j;
        -:   43:  int it;			
        -:   44:  //set up random number generator
     2000:   45:  SelectStream(1);
call    0 returned 2000
     2000:   46:  PutSeed((long)randomSeed);
call    0 returned 2000
        -:   47:  
        -:   48:  //check number of players
     2000:   49:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 2000 (fallthrough)
branch  1 taken 0
branch  2 taken 683 (fallthrough)
branch  3 taken 1317
        -:   50:    {
      683:   51:      return -1;
        -:   52:    }
        -:   53:
        -:   54:  //set number of players
     1317:   55:  state->numPlayers = numPlayers;
        -:   56:
        -:   57:  //check selected kingdom cards are different
    14487:   58:  for (i = 0; i < 10; i++)
branch  0 taken 13170
branch  1 taken 1317 (fallthrough)
        -:   59:    {
   144870:   60:      for (j = 0; j < 10; j++)
branch  0 taken 131700
branch  1 taken 13170 (fallthrough)
        -:   61:        {
   131700:   62:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 118530 (fallthrough)
branch  1 taken 13170
branch  2 taken 0 (fallthrough)
branch  3 taken 118530
        -:   63:	    {
    #####:   64:	      return -1;
        -:   65:	    }
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:  //initialize supply
        -:   71:  ///////////////////////////////
        -:   72:
        -:   73:  //set number of Curse cards
     1317:   74:  if (numPlayers == 2)
branch  0 taken 667 (fallthrough)
branch  1 taken 650
        -:   75:    {
      667:   76:      state->supplyCount[curse] = 10;
        -:   77:    }
      650:   78:  else if (numPlayers == 3)
branch  0 taken 650 (fallthrough)
branch  1 taken 0
        -:   79:    {
      650:   80:      state->supplyCount[curse] = 20;
        -:   81:    }
        -:   82:  else
        -:   83:    {
    #####:   84:      state->supplyCount[curse] = 30;
        -:   85:    }
        -:   86:
        -:   87:  //set number of Victory cards
     1317:   88:  if (numPlayers == 2)
branch  0 taken 667 (fallthrough)
branch  1 taken 650
        -:   89:    {
      667:   90:      state->supplyCount[estate] = 8;
      667:   91:      state->supplyCount[duchy] = 8;
      667:   92:      state->supplyCount[province] = 8;
        -:   93:    }
        -:   94:  else
        -:   95:    {
      650:   96:      state->supplyCount[estate] = 12;
      650:   97:      state->supplyCount[duchy] = 12;
      650:   98:      state->supplyCount[province] = 12;
        -:   99:    }
        -:  100:
        -:  101:  //set number of Treasure cards
     1317:  102:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     1317:  103:  state->supplyCount[silver] = 40;
     1317:  104:  state->supplyCount[gold] = 30;
        -:  105:
        -:  106:  //set number of Kingdom cards
    27657:  107:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 26340
branch  1 taken 1317 (fallthrough)
        -:  108:    {
   217305:  109:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 204135
branch  1 taken 13170 (fallthrough)
        -:  110:	{
   204135:  111:	  if (kingdomCards[j] == i)
branch  0 taken 13170 (fallthrough)
branch  1 taken 190965
        -:  112:	    {
        -:  113:	      //check if card is a 'Victory' Kingdom card
    13170:  114:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 13170 (fallthrough)
branch  1 taken 0
branch  2 taken 1317 (fallthrough)
branch  3 taken 11853
        -:  115:		{
     2634:  116:		  if (numPlayers == 2){ 
branch  0 taken 667 (fallthrough)
branch  1 taken 650
      667:  117:		    state->supplyCount[i] = 8; 
        -:  118:		  }
      650:  119:		  else{ state->supplyCount[i] = 12; }
        -:  120:		}
        -:  121:	      else
        -:  122:		{
    11853:  123:		  state->supplyCount[i] = 10;
        -:  124:		}
    13170:  125:	      break;
        -:  126:	    }
        -:  127:	  else    //card is not in the set choosen for the game
        -:  128:	    {
   190965:  129:	      state->supplyCount[i] = -1;
        -:  130:	    }
        -:  131:	}
        -:  132:
        -:  133:    }
        -:  134:
        -:  135:  ////////////////////////
        -:  136:  //supply intilization complete
        -:  137:
        -:  138:  //set player decks
     4601:  139:  for (i = 0; i < numPlayers; i++)
branch  0 taken 3284
branch  1 taken 1317 (fallthrough)
        -:  140:    {
     3284:  141:      state->deckCount[i] = 0;
    13136:  142:      for (j = 0; j < 3; j++)
branch  0 taken 9852
branch  1 taken 3284 (fallthrough)
        -:  143:	{
     9852:  144:	  state->deck[i][j] = estate;
     9852:  145:	  state->deckCount[i]++;
        -:  146:	}
    26272:  147:      for (j = 3; j < 10; j++)
branch  0 taken 22988
branch  1 taken 3284 (fallthrough)
        -:  148:	{
    22988:  149:	  state->deck[i][j] = copper;
    22988:  150:	  state->deckCount[i]++;		
        -:  151:	}
        -:  152:    }
        -:  153:
        -:  154:  //shuffle player decks
     4601:  155:  for (i = 0; i < numPlayers; i++)
branch  0 taken 3284
branch  1 taken 1317 (fallthrough)
        -:  156:    {
     3284:  157:      if ( shuffle(i, state) < 0 )
call    0 returned 3284
branch  1 taken 0 (fallthrough)
branch  2 taken 3284
        -:  158:	{
    #####:  159:	  return -1;
        -:  160:	}
        -:  161:    }
        -:  162:
        -:  163:  //draw player hands
     4601:  164:  for (i = 0; i < numPlayers; i++)
branch  0 taken 3284
branch  1 taken 1317 (fallthrough)
        -:  165:    {  
        -:  166:      //initialize hand size to zero
     3284:  167:      state->handCount[i] = 0;
     3284:  168:      state->discardCount[i] = 0;
        -:  169:      //draw 5 cards
        -:  170:      // for (j = 0; j < 5; j++)
        -:  171:      //	{
        -:  172:      //	  drawCard(i, state);
        -:  173:      //	}
        -:  174:    }
        -:  175:  
        -:  176:  //set embargo tokens to 0 for all supply piles
    36876:  177:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 35559
branch  1 taken 1317 (fallthrough)
        -:  178:    {
    35559:  179:      state->embargoTokens[i] = 0;
        -:  180:    }
        -:  181:
        -:  182:  //initialize first player's turn
     1317:  183:  state->outpostPlayed = 0;
     1317:  184:  state->phase = 0;
     1317:  185:  state->numActions = 1;
     1317:  186:  state->numBuys = 1;
     1317:  187:  state->playedCardCount = 0;
     1317:  188:  state->whoseTurn = 0;
     1317:  189:  state->handCount[state->whoseTurn] = 0;
        -:  190:  //int it; move to top
        -:  191:
        -:  192:  //Moved draw cards to here, only drawing at the start of a turn
     7902:  193:  for (it = 0; it < 5; it++){
branch  0 taken 6585
branch  1 taken 1317 (fallthrough)
     6585:  194:    drawCard(state->whoseTurn, state);
call    0 returned 6585
        -:  195:  }
        -:  196:
     1317:  197:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 1317
        -:  198:
     1317:  199:  return 0;
        -:  200:}
        -:  201:
function shuffle called 39745 returned 100% blocks executed 100%
    39745:  202:int shuffle(int player, struct gameState *state) {
        -:  203: 
        -:  204:
        -:  205:  int newDeck[MAX_DECK * 2];
    39745:  206:  int newDeckPos = 0;
        -:  207:  int card;
        -:  208:  int i;
        -:  209:
    39745:  210:  if (state->deckCount[player] < 1)
branch  0 taken 1738 (fallthrough)
branch  1 taken 38007
     1738:  211:    return -1;
    38007:  212:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 38007
        -:  213:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  214:
        -:  215:  //assert(state->deckCount[player] <= MAX_DECK);
   890400:  216:  while (state->deckCount[player] > 0) {
branch  0 taken 814386
branch  1 taken 38007 (fallthrough)
   814386:  217:    card = floor(Random() * state->deckCount[player]);
call    0 returned 814386
   814386:  218:    newDeck[newDeckPos] = state->deck[player][card];
   814386:  219:    newDeckPos++;
  6842653:  220:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 6028267
branch  1 taken 814386 (fallthrough)
  6028267:  221:      state->deck[player][i] = state->deck[player][i+1];
        -:  222:    }
   814386:  223:    state->deckCount[player]--;
        -:  224:  }
   852393:  225:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 814386
branch  1 taken 38007 (fallthrough)
   814386:  226:    state->deck[player][i] = newDeck[i];
   814386:  227:    state->deckCount[player]++;
        -:  228:  }
        -:  229:
    38007:  230:  return 0;
        -:  231:}
        -:  232:
function playCard called 132490 returned 100% blocks executed 100%
   132490:  233:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  234:{	
        -:  235:  int card;
   132490:  236:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  237:
        -:  238:  //check if it is the right phase
   132490:  239:  if (state->phase != 0)
branch  0 taken 18160 (fallthrough)
branch  1 taken 114330
        -:  240:    {
    18160:  241:      return -1;
        -:  242:    }
        -:  243:	
        -:  244:  //check if player has enough actions
   114330:  245:  if ( state->numActions < 1 )
branch  0 taken 20615 (fallthrough)
branch  1 taken 93715
        -:  246:    {
    20615:  247:      return -1;
        -:  248:    }
        -:  249:	
        -:  250:  //get card played
    93715:  251:  card = handCard(handPos, state);
call    0 returned 93715
        -:  252:	
        -:  253:  //check if selected card is an action
    93715:  254:  if ( card < adventurer || card > treasure_map )
branch  0 taken 47942 (fallthrough)
branch  1 taken 45773
branch  2 taken 0 (fallthrough)
branch  3 taken 47942
        -:  255:    {
    45773:  256:      return -1;
        -:  257:    }
        -:  258:	
        -:  259:  //play card
    47942:  260:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 returned 47942
branch  1 taken 12602 (fallthrough)
branch  2 taken 35340
        -:  261:    {
    12602:  262:      return -1;
        -:  263:    }
        -:  264:	
        -:  265:  //reduce number of actions
    35340:  266:  state->numActions--;
        -:  267:
        -:  268:  //update coins (Treasure cards may be added with card draws)
    35340:  269:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 returned 35340
        -:  270:	
    35340:  271:  return 0;
        -:  272:}
        -:  273:
function buyCard called 132446 returned 100% blocks executed 100%
   132446:  274:int buyCard(int supplyPos, struct gameState *state) {
        -:  275:  int who;
        -:  276:  if (DEBUG){
        -:  277:    printf("Entering buyCard...\n");
        -:  278:  }
        -:  279:
        -:  280:  // I don't know what to do about the phase thing.
        -:  281:
   132446:  282:  who = state->whoseTurn;
        -:  283:
   132446:  284:  if (state->numBuys < 1){
branch  0 taken 17305 (fallthrough)
branch  1 taken 115141
        -:  285:    if (DEBUG)
        -:  286:      printf("You do not have any buys left\n");
    17305:  287:    return -1;
   115141:  288:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 115141
branch  1 taken 34769 (fallthrough)
branch  2 taken 80372
        -:  289:    if (DEBUG)
        -:  290:      printf("There are not any of that type of card left\n");
    34769:  291:    return -1;
    80372:  292:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 80372
branch  1 taken 61753 (fallthrough)
branch  2 taken 18619
        -:  293:    if (DEBUG) 
        -:  294:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    61753:  295:    return -1;
        -:  296:  } else {
    18619:  297:    state->phase=1;
        -:  298:    //state->supplyCount[supplyPos]--;
    18619:  299:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 18619
        -:  300:  
    18619:  301:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 18619
    18619:  302:    state->numBuys--;
        -:  303:    if (DEBUG)
        -:  304:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  305:  }
        -:  306:
        -:  307:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  308:  //state->discardCount[who]++;
        -:  309:    
    18619:  310:  return 0;
        -:  311:}
        -:  312:
function numHandCards called 267492 returned 100% blocks executed 100%
   267492:  313:int numHandCards(struct gameState *state) {
   267492:  314:  return state->handCount[ whoseTurn(state) ];
call    0 returned 267492
        -:  315:}
        -:  316:
function handCard called 886986 returned 100% blocks executed 100%
   886986:  317:int handCard(int handPos, struct gameState *state) {
   886986:  318:  int currentPlayer = whoseTurn(state);
call    0 returned 886986
   886986:  319:  return state->hand[currentPlayer][handPos];
        -:  320:}
        -:  321:
function supplyCount called 150711 returned 100% blocks executed 100%
   150711:  322:int supplyCount(int card, struct gameState *state) {
   150711:  323:  return state->supplyCount[card];
        -:  324:}
        -:  325:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  326:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  327:  int i;
    #####:  328:  int count = 0;
        -:  329:
    #####:  330:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  331:    {
    #####:  332:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  333:    }
        -:  334:
    #####:  335:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  336:    {
    #####:  337:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  338:    }
        -:  339:
    #####:  340:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  341:    {
    #####:  342:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  343:    }
        -:  344:
    #####:  345:  return count;
        -:  346:}
        -:  347:
function whoseTurn called 1474571 returned 100% blocks executed 100%
  1474571:  348:int whoseTurn(struct gameState *state) {
  1474571:  349:  return state->whoseTurn;
        -:  350:}
        -:  351:
function endTurn called 132174 returned 100% blocks executed 100%
   132174:  352:int endTurn(struct gameState *state) {
        -:  353:  int k;
        -:  354:  int i;
   132174:  355:  int currentPlayer = whoseTurn(state);
call    0 returned 132174
        -:  356:  
        -:  357:  //Discard hand
   927120:  358:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 794946
branch  1 taken 132174 (fallthrough)
        -:  359:    //assert(state->discardCount[currentPlayer] < MAX_DECK);
   794946:  360:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
   794946:  361:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:  }
   132174:  363:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:    
        -:  365:  //Code for determining the player
   132174:  366:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 76730 (fallthrough)
branch  1 taken 55444
    76730:  367:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:  }
        -:  369:  else{
    55444:  370:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:  }
        -:  372:
   132174:  373:  state->outpostPlayed = 0;
   132174:  374:  state->phase = 0;
   132174:  375:  state->numActions = 1;
   132174:  376:  state->coins = 0;
   132174:  377:  state->numBuys = 1;
   132174:  378:  state->playedCardCount = 0;
   132174:  379:  state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:  //int k; move to top
        -:  382:  //Next player draws hand
   793044:  383:  for (k = 0; k < 5; k++){
branch  0 taken 660870
branch  1 taken 132174 (fallthrough)
   660870:  384:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 660870
        -:  385:  }
        -:  386:
        -:  387:  //Update money
   132174:  388:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 132174
        -:  389:
   132174:  390:  return 0;
        -:  391:}
        -:  392:
function isGameOver called 664424 returned 100% blocks executed 91%
   664424:  393:int isGameOver(struct gameState *state) {
        -:  394:  int i;
        -:  395:  int j;
        -:  396:	
        -:  397:  //if stack of Province cards is empty, the game ends
   664424:  398:  if (state->supplyCount[province] == 0)
branch  0 taken 683 (fallthrough)
branch  1 taken 663741
        -:  399:    {
      683:  400:      return 1;
        -:  401:    }
        -:  402:
        -:  403:  //if three supply pile are at 0, the game ends
   663741:  404:  j = 0;
 17257266:  405:  for (i = 0; i < 25; i++)
branch  0 taken 16593525
branch  1 taken 663741 (fallthrough)
        -:  406:    {
 16593525:  407:      if (state->supplyCount[i] == 0)
branch  0 taken 41137 (fallthrough)
branch  1 taken 16552388
        -:  408:	{
    41137:  409:	  j++;
        -:  410:	}
        -:  411:    }
   663741:  412:  if ( j >= 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 663741
        -:  413:    {
    #####:  414:      return 1;
        -:  415:    }
        -:  416:
   663741:  417:  return 0;
        -:  418:}
        -:  419:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  420:int scoreFor (int player, struct gameState *state) {
        -:  421:
        -:  422:  int i;
    #####:  423:  int score = 0;
        -:  424:  //score from hand
    #####:  425:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  426:    {
    #####:  427:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  430:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  431:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  432:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  433:    }
        -:  434:
        -:  435:  //score from discard
    #####:  436:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  437:    {
    #####:  438:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  441:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  442:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  443:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  444:    }
        -:  445:
        -:  446:  //score from deck
    #####:  447:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  448:    {
    #####:  449:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  452:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  453:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  454:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  455:    }
        -:  456:
    #####:  457:  return score;
        -:  458:}
        -:  459:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:  int i;	
        -:  462:  int j;
        -:  463:  int highScore;
        -:  464:  int currentPlayer;
        -:  465:
        -:  466:  //get score for each player
    #####:  467:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  468:    {
        -:  469:      //set unused player scores to -9999
    #####:  470:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  471:	{
    #####:  472:	  players[i] = -9999;
        -:  473:	}
        -:  474:      else
        -:  475:	{
    #####:  476:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  477:	}
        -:  478:    }
        -:  479:
        -:  480:  //find highest score
    #####:  481:  j = 0;
    #####:  482:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  483:    {
    #####:  484:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  485:	{
    #####:  486:	  j = i;
        -:  487:	}
        -:  488:    }
    #####:  489:  highScore = players[j];
        -:  490:
        -:  491:  //add 1 to players who had less turns
    #####:  492:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  493:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  494:    {
    #####:  495:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  496:	{
    #####:  497:	  players[i]++;
        -:  498:	}
        -:  499:    }
        -:  500:
        -:  501:  //find new highest score
    #####:  502:  j = 0;
    #####:  503:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  504:    {
    #####:  505:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  506:	{
    #####:  507:	  j = i;
        -:  508:	}
        -:  509:    }
    #####:  510:  highScore = players[j];
        -:  511:
        -:  512:  //set winners in array to 1 and rest to 0
    #####:  513:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  514:    {
    #####:  515:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  516:	{
    #####:  517:	  players[i] = 1;
        -:  518:	}
        -:  519:      else
        -:  520:	{
    #####:  521:	  players[i] = 0;
        -:  522:	}
        -:  523:    }
        -:  524:
    #####:  525:  return 0;
        -:  526:}
        -:  527:
function drawCard called 733646 returned 100% blocks executed 100%
   733646:  528:int drawCard(int player, struct gameState *state)
        -:  529:{	int count;
        -:  530:  int deckCounter;
   733646:  531:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 35130 (fallthrough)
branch  1 taken 698516
        -:  532:    
        -:  533:    //Step 1 Shuffle the discard pile back into a deck
        -:  534:    int i;
        -:  535:    //Move discard to deck
   814820:  536:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 779690
branch  1 taken 35130 (fallthrough)
   779690:  537:      state->deck[player][i] = state->discard[player][i];
   779690:  538:      state->discard[player][i] = -1;
        -:  539:    }
        -:  540:
        -:  541:    //assert(state->discardCount[player] <= MAX_DECK);
    35130:  542:    state->deckCount[player] = state->discardCount[player];
    35130:  543:    state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:    //Shufffle the deck
    35130:  546:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 35130
        -:  547:   
        -:  548:    if (DEBUG){//Debug statements
        -:  549:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:    }
        -:  551:    
    35130:  552:    state->discardCount[player] = 0;
        -:  553:
        -:  554:    //Step 2 Draw Card
    35130:  555:    count = state->handCount[player];//Get current player's hand count
        -:  556:    
        -:  557:    if (DEBUG){//Debug statements
        -:  558:      printf("Current hand count: %d\n", count);
        -:  559:    }
        -:  560:    
    35130:  561:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
    35130:  563:    if (deckCounter == 0)
branch  0 taken 556 (fallthrough)
branch  1 taken 34574
      556:  564:      return -1;
        -:  565:
    34574:  566:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    34574:  567:    state->deckCount[player]--;
    34574:  568:    state->handCount[player]++;//Increment hand count
        -:  569:  }
        -:  570:
        -:  571:  else{
   698516:  572:    int count = state->handCount[player];//Get current hand count for player
        -:  573:    int deckCounter;
        -:  574:    if (DEBUG){//Debug statements
        -:  575:      printf("Current hand count: %d\n", count);
        -:  576:    }
        -:  577:
   698516:  578:    deckCounter = state->deckCount[player];//Create holder for the deck count
   698516:  579:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
   698516:  580:    state->deckCount[player]--;
   698516:  581:    state->handCount[player]++;//Increment hand count
        -:  582:  }
        -:  583:
   733090:  584:  return 0;
        -:  585:}
        -:  586:
function getCost called 109981 returned 100% blocks executed 100%
   109981:  587:int getCost(int cardNumber)
        -:  588:{
   109981:  589:  switch( cardNumber ) 
branch  0 taken 12500
branch  1 taken 9037
branch  2 taken 6765
branch  3 taken 6617
branch  4 taken 13346
branch  5 taken 7516
branch  6 taken 5887
branch  7 taken 6108
branch  8 taken 99
branch  9 taken 66
branch 10 taken 6521
branch 11 taken 6311
branch 12 taken 566
branch 13 taken 6693
branch 14 taken 7252
branch 15 taken 106
branch 16 taken 86
branch 17 taken 6260
branch 18 taken 98
branch 19 taken 6283
branch 20 taken 136
branch 21 taken 294
branch 22 taken 283
branch 23 taken 89
branch 24 taken 402
branch 25 taken 318
branch 26 taken 116
branch 27 taken 226
        -:  590:    {
    12500:  591:    case curse:
    12500:  592:      return 0;
     9037:  593:    case estate:
     9037:  594:      return 2;
     6765:  595:    case duchy:
     6765:  596:      return 5;
     6617:  597:    case province:
     6617:  598:      return 8;
    13346:  599:    case copper:
    13346:  600:      return 0;
     7516:  601:    case silver:
     7516:  602:      return 3;
     5887:  603:    case gold:
     5887:  604:      return 6;
     6108:  605:    case adventurer:
     6108:  606:      return 6;
       99:  607:    case council_room:
       99:  608:      return 5;
       66:  609:    case feast:
       66:  610:      return 4;
     6521:  611:    case gardens:
     6521:  612:      return 4;
     6311:  613:    case mine:
     6311:  614:      return 5;
      566:  615:    case remodel:
      566:  616:      return 4;
     6693:  617:    case smithy:
     6693:  618:      return 4;
     7252:  619:    case village:
     7252:  620:      return 3;
      106:  621:    case baron:
      106:  622:      return 4;
       86:  623:    case great_hall:
       86:  624:      return 3;
     6260:  625:    case minion:
     6260:  626:      return 5;
       98:  627:    case steward:
       98:  628:      return 3;
     6283:  629:    case tribute:
     6283:  630:      return 5;
      136:  631:    case ambassador:
      136:  632:      return 3;
      294:  633:    case cutpurse:
      294:  634:      return 4;
      283:  635:    case embargo: 
      283:  636:      return 2;
       89:  637:    case outpost:
       89:  638:      return 5;
      402:  639:    case salvager:
      402:  640:      return 4;
      318:  641:    case sea_hag:
      318:  642:      return 4;
      116:  643:    case treasure_map:
      116:  644:      return 4;
        -:  645:    }
        -:  646:	
      226:  647:  return -1;
        -:  648:}
        -:  649:
function adventurerCardEffect called 2685 returned 100% blocks executed 100%
     2685:  650:int adventurerCardEffect(struct gameState *state, int currentPlayer)
        -:  651:{
     2685:  652:  int drawntreasure = 0;
        -:  653:  int cardDrawn;
     2685:  654:  int z = 0;// this is the counter for the temp hand
        -:  655:  int temphand[MAX_HAND * 2];
        -:  656:
    35451:  657:  while(drawntreasure<2 && z<MAX_HAND){
branch  0 taken 30103 (fallthrough)
branch  1 taken 2663
branch  2 taken 30103
branch  3 taken 0 (fallthrough)
    30103:  658:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 1182 (fallthrough)
branch  1 taken 28921
     1182:  659:      shuffle(currentPlayer, state);
call    0 returned 1182
        -:  660:    }
    30103:  661:    drawCard(currentPlayer, state);
call    0 returned 30103
    30103:  662:    if (state->handCount[currentPlayer] <= 0) {
branch  0 taken 22 (fallthrough)
branch  1 taken 30081
       22:  663:      break;
        -:  664:    }
    30081:  665:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    30081:  666:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 25134 (fallthrough)
branch  1 taken 4947
branch  2 taken 24879 (fallthrough)
branch  3 taken 255
branch  4 taken 124 (fallthrough)
branch  5 taken 24755
     5326:  667:      drawntreasure++;
        -:  668:    else{
    24755:  669:      temphand[z]=cardDrawn;
    24755:  670:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    24755:  671:      z++;
        -:  672:    }
        -:  673:  }
    30125:  674:  while(z-1>=0){
branch  0 taken 24755
branch  1 taken 2685 (fallthrough)
        -:  675:    //assert(state->discardCount[currentPlayer] < MAX_DECK);
    24755:  676:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    24755:  677:    z=z-1;
        -:  678:  }
     2685:  679:  return 0;
        -:  680:}
        -:  681:
function smithyCardEffect called 2213 returned 100% blocks executed 100%
     2213:  682:int smithyCardEffect(struct gameState *state, int handPos, int currentPlayer)
        -:  683:{
        -:  684:  int i;
        -:  685:
        -:  686:  //+3 Cards
     8852:  687:  for (i = 0; i < 3; i++)
branch  0 taken 6639
branch  1 taken 2213 (fallthrough)
        -:  688:    {
     6639:  689:      drawCard(currentPlayer, state);
call    0 returned 6639
        -:  690:    }
        -:  691:
        -:  692:  //discard card from hand
     2213:  693:  discardCard(handPos, currentPlayer, state, 1);
call    0 returned 2213
     2213:  694:  return 0;
        -:  695:}
        -:  696:
function councilRoomCardEffect called 3815 returned 100% blocks executed 100%
     3815:  697:int councilRoomCardEffect(struct gameState *state, int handPos, int currentPlayer)
        -:  698:{
        -:  699:  int i;
        -:  700:
        -:  701:  //+4 Cards
    19075:  702:  for (i = 0; i < 4; i++)
branch  0 taken 15260
branch  1 taken 3815 (fallthrough)
        -:  703:    {
    15260:  704:      drawCard(currentPlayer, state);
call    0 returned 15260
        -:  705:    }
        -:  706:
        -:  707:  //+1 Buy
     3815:  708:  state->numBuys++;
        -:  709:
        -:  710:  //Each other player draws a card
    13291:  711:  for (i = 0; i < state->numPlayers; i++)
branch  0 taken 9476
branch  1 taken 3815 (fallthrough)
        -:  712:    {
     9476:  713:      if ( i != currentPlayer )
branch  0 taken 5661 (fallthrough)
branch  1 taken 3815
        -:  714:        {
     5661:  715:          drawCard(i, state);
call    0 returned 5661
        -:  716:        }
        -:  717:    }
        -:  718:
        -:  719:  //put played card in played card pile
     3815:  720:  discardCard(handPos, currentPlayer, state, 0);
call    0 returned 3815
        -:  721:
     3815:  722:  return 0;
        -:  723:}
        -:  724:
function feastCardEffect called 5832 returned 100% blocks executed 100%
     5832:  725:int feastCardEffect(struct gameState *state, int choice1, int currentPlayer)
        -:  726:{
        -:  727:  int i;
        -:  728:  int x;
        -:  729:  int temphand[MAX_HAND * 2];
        -:  730:
        -:  731:  //gain card with cost up to 5
        -:  732:  //Backup hand
     5832:  733:  int hc = MAX_HAND;
     5832:  734:  if (state->handCount[currentPlayer] < hc) {
branch  0 taken 5832 (fallthrough)
branch  1 taken 0
     5832:  735:    hc = state->handCount[currentPlayer];
        -:  736:  }
    43634:  737:  for (i = 0; i < hc; i++){
branch  0 taken 37802
branch  1 taken 5832 (fallthrough)
    37802:  738:    temphand[i] = state->hand[currentPlayer][i];//Backup card
    37802:  739:    state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  740:  }
        -:  741:  //Backup hand
        -:  742:
        -:  743:  //Update Coins for Buy
     5832:  744:  updateCoins(currentPlayer, state, 5);
call    0 returned 5832
     5832:  745:  x = 1;//Condition to loop on
    14848:  746:  while( x == 1) {//Buy one card
branch  0 taken 5832
branch  1 taken 3184 (fallthrough)
     5832:  747:    if (supplyCount(choice1, state) <= 0){
call    0 returned 5832
branch  1 taken 2077 (fallthrough)
branch  2 taken 3755
        -:  748:      if (DEBUG)
        -:  749:        printf("None of that card left, sorry!\n");
        -:  750:
        -:  751:      if (DEBUG){
        -:  752:        printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  753:      }
     2077:  754:      return 1;
        -:  755:    }
     3755:  756:    else if (state->coins < getCost(choice1)){
call    0 returned 3755
branch  1 taken 571 (fallthrough)
branch  2 taken 3184
      571:  757:      printf("That card is too expensive!\n");
call    0 returned 571
        -:  758:
        -:  759:      if (DEBUG){
        -:  760:        printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  761:      }
      571:  762:      return 1;
        -:  763:    }
        -:  764:    else{
        -:  765:
        -:  766:      if (DEBUG){
        -:  767:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  768:      }
        -:  769:
     3184:  770:      gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 returned 3184
     3184:  771:      x = 0;//No more buying cards
        -:  772:
        -:  773:      if (DEBUG){
        -:  774:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  775:      }
        -:  776:
        -:  777:    }
        -:  778:  }
        -:  779:
        -:  780:  //Reset Hand
    23383:  781:  for (i = 0; i < hc; i++){
branch  0 taken 20199
branch  1 taken 3184 (fallthrough)
    20199:  782:    state->hand[currentPlayer][i] = temphand[i];
    20199:  783:    temphand[i] = -1;
        -:  784:  }
        -:  785:  //Reset Hand
        -:  786:
     3184:  787:  return 0;
        -:  788:}
        -:  789:
function mineCardEffect called 3021 returned 100% blocks executed 95%
     3021:  790:int mineCardEffect(struct gameState *state, int choice1, int choice2, int handPos, int currentPlayer)
        -:  791:{
        -:  792:  int i;
        -:  793:  int j;
        -:  794:
     3021:  795:  if (choice1 > state->numPlayers) {
branch  0 taken 1165 (fallthrough)
branch  1 taken 1856
     1165:  796:    return -1;
        -:  797:  }
     1856:  798:  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  799:
     1856:  800:  if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 taken 355 (fallthrough)
branch  1 taken 1501
branch  2 taken 213 (fallthrough)
branch  3 taken 142
        -:  801:    {
     1714:  802:      return -1;
        -:  803:    }
        -:  804:
      142:  805:  if (choice2 > treasure_map || choice2 < curse)
branch  0 taken 142 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 142
        -:  806:    {
    #####:  807:      return -1;
        -:  808:    }
        -:  809:
      142:  810:  if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 returned 142
call    1 returned 142
branch  2 taken 104 (fallthrough)
branch  3 taken 38
        -:  811:    {
      104:  812:      return -1;
        -:  813:    }
        -:  814:
       38:  815:  gainCard(choice2, state, 2, currentPlayer);
call    0 returned 38
        -:  816:
        -:  817:  //discard card from hand
       38:  818:  discardCard(handPos, currentPlayer, state, 0);
call    0 returned 38
        -:  819:
        -:  820:  //discard trashed card
      166:  821:  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 154
branch  1 taken 12 (fallthrough)
        -:  822:    {
      154:  823:      if (state->hand[currentPlayer][i] == j)
branch  0 taken 26 (fallthrough)
branch  1 taken 128
        -:  824:        {
       26:  825:          discardCard(i, currentPlayer, state, 0);
call    0 returned 26
       26:  826:          break;
        -:  827:        }
        -:  828:    }
        -:  829:
       38:  830:  return 0;
        -:  831:}
        -:  832:
function cardEffect called 47942 returned 100% blocks executed 93%
    47942:  833:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  834:{
        -:  835:  int i;
        -:  836:  int j;
        -:  837:  int k;
        -:  838:  int index;
    47942:  839:  int currentPlayer = whoseTurn(state);
call    0 returned 47942
    47942:  840:  int nextPlayer = currentPlayer + 1;
        -:  841:
    47942:  842:  int tributeRevealedCards[2] = {-1, -1};
    47942:  843:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 taken 20189 (fallthrough)
branch  1 taken 27753
    20189:  844:    nextPlayer = 0;
        -:  845:  }
        -:  846:  
        -:  847:	
        -:  848:  //uses switch to select card and perform actions
    47942:  849:  switch( card ) 
branch  0 taken 2685
branch  1 taken 1300
branch  2 taken 1727
branch  3 taken 3271
branch  4 taken 3021
branch  5 taken 2586
branch  6 taken 2213
branch  7 taken 2549
branch  8 taken 2624
branch  9 taken 2021
branch 10 taken 2143
branch 11 taken 2129
branch 12 taken 3219
branch 13 taken 2824
branch 14 taken 2088
branch 15 taken 2001
branch 16 taken 2011
branch 17 taken 2142
branch 18 taken 2776
branch 19 taken 2612
branch 20 taken 0
        -:  850:    {
     2685:  851:    case adventurer:
     2685:  852:      return adventurerCardEffect(state, currentPlayer);
call    0 returned 2685
        -:  853:			
     1300:  854:    case council_room:
     1300:  855:      return councilRoomCardEffect(state, handPos, currentPlayer);
call    0 returned 1300
        -:  856:			
     1727:  857:    case feast:
     1727:  858:      return feastCardEffect(state, choice1, currentPlayer);
call    0 returned 1727
        -:  859:			
     3271:  860:    case gardens:
     3271:  861:      return -1;
        -:  862:			
     3021:  863:    case mine:
     3021:  864:      return mineCardEffect(state, choice1, choice2, currentPlayer, handPos);
call    0 returned 3021
        -:  865:			
     2586:  866:    case remodel:
     2586:  867:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  868:
     2586:  869:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 returned 2586
call    1 returned 2586
branch  2 taken 1683 (fallthrough)
branch  3 taken 903
        -:  870:	{
     1683:  871:	  return -1;
        -:  872:	}
        -:  873:
      903:  874:      gainCard(choice2, state, 0, currentPlayer);
call    0 returned 903
        -:  875:
        -:  876:      //discard card from hand
      903:  877:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 903
        -:  878:
        -:  879:      //discard trashed card
     2477:  880:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 2402
branch  1 taken 75 (fallthrough)
        -:  881:	{
     2402:  882:	  if (state->hand[currentPlayer][i] == j)
branch  0 taken 828 (fallthrough)
branch  1 taken 1574
        -:  883:	    {
      828:  884:	      discardCard(i, currentPlayer, state, 0);			
call    0 returned 828
      828:  885:	      break;
        -:  886:	    }
        -:  887:	}
        -:  888:
        -:  889:
      903:  890:      return 0;
        -:  891:		
     2213:  892:    case smithy:
     2213:  893:      return smithyCardEffect(state, handPos, currentPlayer);
call    0 returned 2213
        -:  894:		
     2549:  895:    case village:
        -:  896:      //+1 Card
     2549:  897:      drawCard(currentPlayer, state);
call    0 returned 2549
        -:  898:			
        -:  899:      //+2 Actions
     2549:  900:      state->numActions = state->numActions + 2;
        -:  901:			
        -:  902:      //discard played card from hand
     2549:  903:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 2549
     2549:  904:      return 0;
        -:  905:		
     2624:  906:    case baron:
     2624:  907:      state->numBuys++;//Increase buys by 1!
     2624:  908:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 taken 2150 (fallthrough)
branch  1 taken 474
     2150:  909:	int p = 0;//Iterator for hand!
     2150:  910:	int card_not_discarded = 1;//Flag for discard set!
    16987:  911:	while(card_not_discarded){
branch  0 taken 12687
branch  1 taken 2150 (fallthrough)
    12687:  912:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 taken 826 (fallthrough)
branch  1 taken 11861
      826:  913:	    state->coins += 4;//Add 4 coins to the amount of coins
        -:  914:	    //assert(state->discardCount[currentPlayer] < MAX_DECK);
      826:  915:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
      826:  916:	    state->discardCount[currentPlayer]++;
     4250:  917:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 taken 3424
branch  1 taken 826 (fallthrough)
     3424:  918:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  919:	    }
      826:  920:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
      826:  921:	    state->handCount[currentPlayer]--;
      826:  922:	    card_not_discarded = 0;//Exit the loop
        -:  923:	  }
    11861:  924:	  else if (p > state->handCount[currentPlayer]){
branch  0 taken 1324 (fallthrough)
branch  1 taken 10537
        -:  925:	    if(DEBUG) {
        -:  926:	      printf("No estate cards in your hand, invalid choice\n");
        -:  927:	      printf("Must gain an estate if there are any\n");
        -:  928:	    }
     1324:  929:	    if (supplyCount(estate, state) > 0){
call    0 returned 1324
branch  1 taken 1157 (fallthrough)
branch  2 taken 167
     1157:  930:	      gainCard(estate, state, 0, currentPlayer);
call    0 returned 1157
     1157:  931:	      state->supplyCount[estate]--;//Decrement estates
     1157:  932:	      if (supplyCount(estate, state) == 0){
call    0 returned 1157
branch  1 taken 70 (fallthrough)
branch  2 taken 1087
       70:  933:		isGameOver(state);
call    0 returned 70
        -:  934:	      }
        -:  935:	    }
     1324:  936:	    card_not_discarded = 0;//Exit the loop
        -:  937:	  }
        -:  938:			    
        -:  939:	  else{
    10537:  940:	    p++;//Next card
        -:  941:	  }
        -:  942:	}
        -:  943:      }
        -:  944:			    
        -:  945:      else{
      474:  946:	if (supplyCount(estate, state) > 0){
call    0 returned 474
branch  1 taken 424 (fallthrough)
branch  2 taken 50
      424:  947:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 returned 424
      424:  948:	  state->supplyCount[estate]--;//Decrement Estates
      424:  949:	  if (supplyCount(estate, state) == 0){
call    0 returned 424
branch  1 taken 23 (fallthrough)
branch  2 taken 401
       23:  950:	    isGameOver(state);
call    0 returned 23
        -:  951:	  }
        -:  952:	}
        -:  953:      }
        -:  954:	    
        -:  955:      
     2624:  956:      return 0;
        -:  957:		
     2021:  958:    case great_hall:
        -:  959:      //+1 Card
     2021:  960:      drawCard(currentPlayer, state);
call    0 returned 2021
        -:  961:			
        -:  962:      //+1 Actions
     2021:  963:      state->numActions++;
        -:  964:			
        -:  965:      //discard card from hand
     2021:  966:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 2021
     2021:  967:      return 0;
        -:  968:		
     2143:  969:    case minion:
        -:  970:      //+1 action
     2143:  971:      state->numActions++;
        -:  972:			
        -:  973:      //discard card from hand
     2143:  974:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 2143
        -:  975:			
     2143:  976:      if (choice1)		//+2 coins
branch  0 taken 1744 (fallthrough)
branch  1 taken 399
        -:  977:	{
     1744:  978:	  state->coins = state->coins + 2;
        -:  979:	}
        -:  980:			
      399:  981:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 taken 322 (fallthrough)
branch  1 taken 77
        -:  982:	{
        -:  983:	  //discard hand
     2143:  984:	  while(numHandCards(state) > 0)
call    0 returned 1821
branch  1 taken 1499
branch  2 taken 322 (fallthrough)
        -:  985:	    {
     1499:  986:	      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 1499
        -:  987:	    }
        -:  988:				
        -:  989:	  //draw 4
     1610:  990:	  for (i = 0; i < 4; i++)
branch  0 taken 1288
branch  1 taken 322 (fallthrough)
        -:  991:	    {
     1288:  992:	      drawCard(currentPlayer, state);
call    0 returned 1288
        -:  993:	    }
        -:  994:				
        -:  995:	  //other players discard hand and redraw if hand size > 4
     1129:  996:	  for (i = 0; i < state->numPlayers; i++)
branch  0 taken 807
branch  1 taken 322 (fallthrough)
        -:  997:	    {
      807:  998:	      if (i != currentPlayer)
branch  0 taken 485 (fallthrough)
branch  1 taken 322
        -:  999:		{
      485: 1000:		  if ( state->handCount[i] > 4 )
branch  0 taken 0 (fallthrough)
branch  1 taken 485
        -: 1001:		    {
        -: 1002:		      //discard hand
    #####: 1003:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1004:			{
    #####: 1005:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1006:			}
        -: 1007:							
        -: 1008:		      //draw 4
    #####: 1009:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1010:			{
    #####: 1011:			  drawCard(i, state);
call    0 never executed
        -: 1012:			}
        -: 1013:		    }
        -: 1014:		}
        -: 1015:	    }
        -: 1016:				
        -: 1017:	}
     2143: 1018:      return 0;
        -: 1019:		
     2129: 1020:    case steward:
     2129: 1021:      if (choice1 == 1)
branch  0 taken 387 (fallthrough)
branch  1 taken 1742
        -: 1022:	{
        -: 1023:	  //+2 cards
      387: 1024:	  drawCard(currentPlayer, state);
call    0 returned 387
      387: 1025:	  drawCard(currentPlayer, state);
call    0 returned 387
        -: 1026:	}
     1742: 1027:      else if (choice1 == 2)
branch  0 taken 392 (fallthrough)
branch  1 taken 1350
        -: 1028:	{
        -: 1029:	  //+2 coins
      392: 1030:	  state->coins = state->coins + 2;
        -: 1031:	}
        -: 1032:      else
        -: 1033:	{
        -: 1034:	  //trash 2 cards in hand
     1350: 1035:	  discardCard(choice2, currentPlayer, state, 1);
call    0 returned 1350
     1350: 1036:	  discardCard(choice3, currentPlayer, state, 1);
call    0 returned 1350
        -: 1037:	}
        -: 1038:			
        -: 1039:      //discard card from hand
     2129: 1040:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 2129
     2129: 1041:      return 0;
        -: 1042:		
     3219: 1043:    case tribute:
     3219: 1044:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 taken 1 (fallthrough)
branch  1 taken 3218
        1: 1045:	if (state->deckCount[nextPlayer] > 0){
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1046:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1047:	  state->deckCount[nextPlayer]--;
        -: 1048:	}
        1: 1049:	else if (state->discardCount[nextPlayer] > 0){
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1050:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1051:	  state->discardCount[nextPlayer]--;
        -: 1052:	}
        -: 1053:	else{
        -: 1054:	  //No Card to Reveal
        -: 1055:	  if (DEBUG){
        -: 1056:	    printf("No cards to reveal\n");
        -: 1057:	  }
        -: 1058:	}
        -: 1059:      }
        -: 1060:	    
        -: 1061:      else{
     3218: 1062:	if (state->deckCount[nextPlayer] == 0){
branch  0 taken 149 (fallthrough)
branch  1 taken 3069
     2005: 1063:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 taken 1856
branch  1 taken 149 (fallthrough)
     1856: 1064:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
        -: 1065:	    //assert(state->deckCount[nextPlayer] < MAX_DECK);
     1856: 1066:	    state->deckCount[nextPlayer]++;
     1856: 1067:	    state->discard[nextPlayer][i] = -1;
     1856: 1068:	    state->discardCount[nextPlayer]--;
        -: 1069:	  }
        -: 1070:			    
      149: 1071:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 returned 149
        -: 1072:	} 
     3218: 1073:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
     3218: 1074:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
     3218: 1075:	state->deckCount[nextPlayer]--;
     3218: 1076:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
     3218: 1077:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
     3218: 1078:	state->deckCount[nextPlayer]--;
        -: 1079:      }    
        -: 1080:		       
     3219: 1081:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 taken 410 (fallthrough)
branch  1 taken 2809
      410: 1082:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
      410: 1083:	state->playedCardCount++;
      410: 1084:	tributeRevealedCards[1] = -1;
        -: 1085:      }
        -: 1086:
    12876: 1087:      for (i = 0; i <= 2; i ++){
branch  0 taken 9657
branch  1 taken 3219 (fallthrough)
     9657: 1088:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 taken 8560 (fallthrough)
branch  1 taken 1097
branch  2 taken 8496 (fallthrough)
branch  3 taken 64
branch  4 taken 51 (fallthrough)
branch  5 taken 8445
     1212: 1089:	  state->coins += 2;
        -: 1090:	}
        -: 1091:		    
     8445: 1092:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 taken 7886 (fallthrough)
branch  1 taken 559
branch  2 taken 7865 (fallthrough)
branch  3 taken 21
branch  4 taken 7852 (fallthrough)
branch  5 taken 13
branch  6 taken 7647 (fallthrough)
branch  7 taken 205
branch  8 taken 150 (fallthrough)
branch  9 taken 7497
      948: 1093:	  drawCard(currentPlayer, state);
call    0 returned 948
      948: 1094:	  drawCard(currentPlayer, state);
call    0 returned 948
        -: 1095:	}
        -: 1096:	else{//Action Card
     7497: 1097:	  state->numActions = state->numActions + 2;
        -: 1098:	}
        -: 1099:      }
        -: 1100:	    
     3219: 1101:      return 0;
        -: 1102:		
     2824: 1103:    case ambassador:
     2824: 1104:      j = 0;		//used to check if player has enough cards to discard
        -: 1105:
     2824: 1106:      if (choice2 > 2 || choice2 < 0)
branch  0 taken 1476 (fallthrough)
branch  1 taken 1348
branch  2 taken 0 (fallthrough)
branch  3 taken 1476
        -: 1107:	{
     1348: 1108:	  return -1;				
        -: 1109:	}
        -: 1110:
     1476: 1111:      if (choice1 == handPos)
branch  0 taken 266 (fallthrough)
branch  1 taken 1210
        -: 1112:	{
      266: 1113:	  return -1;
        -: 1114:	}
        -: 1115:
     8048: 1116:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 6838
branch  1 taken 1210 (fallthrough)
        -: 1117:	{
     6838: 1118:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 taken 5628 (fallthrough)
branch  1 taken 1210
branch  2 taken 308 (fallthrough)
branch  3 taken 5320
branch  4 taken 230 (fallthrough)
branch  5 taken 78
        -: 1119:	    {
      230: 1120:	      j++;
        -: 1121:	    }
        -: 1122:	}
     1210: 1123:      if (j < choice2)
branch  0 taken 749 (fallthrough)
branch  1 taken 461
        -: 1124:	{
      749: 1125:	  return -1;				
        -: 1126:	}
        -: 1127:
        -: 1128:      if (DEBUG) 
        -: 1129:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1130:
        -: 1131:      //increase supply count for choosen card by amount being discarded
      461: 1132:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1133:			
        -: 1134:      //each other player gains a copy of revealed card
     1594: 1135:      for (i = 0; i < state->numPlayers; i++)
branch  0 taken 1133
branch  1 taken 461 (fallthrough)
        -: 1136:	{
     1133: 1137:	  if (i != currentPlayer)
branch  0 taken 686 (fallthrough)
branch  1 taken 447
        -: 1138:	    {
      686: 1139:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 returned 686
        -: 1140:	    }
        -: 1141:	}
        -: 1142:
        -: 1143:      //discard played card from hand
      461: 1144:      discardCard(handPos, currentPlayer, state, 0);			
call    0 returned 461
        -: 1145:
        -: 1146:      //trash copies of cards returned to supply
      541: 1147:      for (j = 0; j < choice2; j++)
branch  0 taken 80
branch  1 taken 461 (fallthrough)
        -: 1148:	{
      181: 1149:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 175
branch  1 taken 6 (fallthrough)
        -: 1150:	    {
      175: 1151:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 taken 74 (fallthrough)
branch  1 taken 101
        -: 1152:		{
       74: 1153:		  discardCard(i, currentPlayer, state, 1);
call    0 returned 74
       74: 1154:		  break;
        -: 1155:		}
        -: 1156:	    }
        -: 1157:	}			
        -: 1158:
      461: 1159:      return 0;
        -: 1160:		
     2088: 1161:    case cutpurse:
        -: 1162:
     2088: 1163:      updateCoins(currentPlayer, state, 2);
call    0 returned 2088
     7238: 1164:      for (i = 0; i < state->numPlayers; i++)
branch  0 taken 5150
branch  1 taken 2088 (fallthrough)
        -: 1165:	{
     5150: 1166:	  if (i != currentPlayer)
branch  0 taken 3062 (fallthrough)
branch  1 taken 2088
        -: 1167:	    {
     3110: 1168:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 taken 67
branch  1 taken 3043 (fallthrough)
        -: 1169:		{
       67: 1170:		  if (state->hand[i][j] == copper)
branch  0 taken 19 (fallthrough)
branch  1 taken 48
        -: 1171:		    {
       19: 1172:		      discardCard(j, i, state, 0);
call    0 returned 19
       19: 1173:		      break;
        -: 1174:		    }
       48: 1175:		  if (j == state->handCount[i])
branch  0 taken 0 (fallthrough)
branch  1 taken 48
        -: 1176:		    {
    #####: 1177:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1178:			{
        -: 1179:			  if (DEBUG)
        -: 1180:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1181:			}	
    #####: 1182:		      break;
        -: 1183:		    }		
        -: 1184:		}
        -: 1185:					
        -: 1186:	    }
        -: 1187:				
        -: 1188:	}				
        -: 1189:
        -: 1190:      //discard played card from hand
     2088: 1191:      discardCard(handPos, currentPlayer, state, 0);			
call    0 returned 2088
        -: 1192:
     2088: 1193:      return 0;
        -: 1194:
        -: 1195:		
     2001: 1196:    case embargo: 
        -: 1197:      //+2 Coins
     2001: 1198:      state->coins = state->coins + 2;
        -: 1199:			
        -: 1200:      //see if selected pile is in play
     2001: 1201:      if ( state->supplyCount[choice1] == -1 )
branch  0 taken 27 (fallthrough)
branch  1 taken 1974
        -: 1202:	{
       27: 1203:	  return -1;
        -: 1204:	}
        -: 1205:			
        -: 1206:      //add embargo token to selected supply pile
     1974: 1207:      state->embargoTokens[choice1]++;
        -: 1208:			
        -: 1209:      //trash card
     1974: 1210:      discardCard(handPos, currentPlayer, state, 1);		
call    0 returned 1974
     1974: 1211:      return 0;
        -: 1212:		
     2011: 1213:    case outpost:
        -: 1214:      //set outpost flag
     2011: 1215:      state->outpostPlayed++;
        -: 1216:			
        -: 1217:      //discard card
     2011: 1218:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 2011
     2011: 1219:      return 0;
        -: 1220:		
     2142: 1221:    case salvager:
        -: 1222:      //+1 buy
     2142: 1223:      state->numBuys++;
        -: 1224:			
     2142: 1225:      if (choice1)
branch  0 taken 1779 (fallthrough)
branch  1 taken 363
        -: 1226:	{
        -: 1227:	  //gain coins equal to trashed card
     1779: 1228:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 returned 1779
call    1 returned 1779
        -: 1229:	  //trash card
     1779: 1230:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 returned 1779
        -: 1231:	}
        -: 1232:			
        -: 1233:      //discard card
     2142: 1234:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 2142
     2142: 1235:      return 0;
        -: 1236:		
     2776: 1237:    case sea_hag:
     9649: 1238:      for (i = 0; i < state->numPlayers; i++){
branch  0 taken 6873
branch  1 taken 2776 (fallthrough)
     6873: 1239:	if (i != currentPlayer){
branch  0 taken 4097 (fallthrough)
branch  1 taken 2776
        -: 1240:          //assert(state->deckCount[i] > 0);
        -: 1241:	  //assert(state->discardCount < MAX_DECK);
     4097: 1242:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
     4097: 1243:	  state->discardCount[i]++;
     4097: 1244:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1245:	}
        -: 1246:      }
     2776: 1247:      return 0;
        -: 1248:		
     2612: 1249:    case treasure_map:
        -: 1250:      //search hand for another treasure_map
     2612: 1251:      index = -1;
    16627: 1252:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 14352
branch  1 taken 2275 (fallthrough)
        -: 1253:	{
    14352: 1254:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 taken 2789 (fallthrough)
branch  1 taken 11563
branch  2 taken 337 (fallthrough)
branch  3 taken 2452
        -: 1255:	    {
      337: 1256:	      index = i;
      337: 1257:	      break;
        -: 1258:	    }
        -: 1259:	}
     2612: 1260:      if (index > -1)
branch  0 taken 337 (fallthrough)
branch  1 taken 2275
        -: 1261:	{
        -: 1262:	  //trash both treasure cards
      337: 1263:	  discardCard(handPos, currentPlayer, state, 1);
call    0 returned 337
      337: 1264:	  discardCard(index, currentPlayer, state, 1);
call    0 returned 337
        -: 1265:
        -: 1266:	  //gain 4 Gold cards
     1685: 1267:	  for (i = 0; i < 4; i++)
branch  0 taken 1348
branch  1 taken 337 (fallthrough)
        -: 1268:	    {
     1348: 1269:	      gainCard(gold, state, 1, currentPlayer);
call    0 returned 1348
        -: 1270:	    }
        -: 1271:				
        -: 1272:	  //return success
      337: 1273:	  return 1;
        -: 1274:	}
        -: 1275:			
        -: 1276:      //no second treasure_map found in hand
     2275: 1277:      return -1;
        -: 1278:    }
        -: 1279:	
    #####: 1280:  return -1;
        -: 1281:}
        -: 1282:
function discardCard called 32086 returned 100% blocks executed 100%
    32086: 1283:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1284:{
        -: 1285:	
        -: 1286:  //if card is not trashed, added to Played pile 
    32086: 1287:  if (trashFlag < 1)
branch  0 taken 22672 (fallthrough)
branch  1 taken 9414
        -: 1288:    {
        -: 1289:      //add card to played pile
    22672: 1290:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    22672: 1291:      state->playedCardCount++;
        -: 1292:    }
        -: 1293:	
        -: 1294:  //set played card to -1
    32086: 1295:  state->hand[currentPlayer][handPos] = -1;
        -: 1296:	
        -: 1297:  //remove card from player's hand
    32086: 1298:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 4391 (fallthrough)
branch  1 taken 27695
        -: 1299:    {
        -: 1300:      //reduce number of cards in hand
     4391: 1301:      state->handCount[currentPlayer]--;
        -: 1302:    }
    27695: 1303:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 275 (fallthrough)
branch  1 taken 27420
        -: 1304:    {
        -: 1305:      //reduce number of cards in hand
      275: 1306:      state->handCount[currentPlayer]--;
        -: 1307:    }
        -: 1308:  else 	
        -: 1309:    {
        -: 1310:      //replace discarded card with last card in hand
    27420: 1311:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1312:      //set last card to -1
    27420: 1313:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1314:      //reduce number of cards in hand
    27420: 1315:      state->handCount[currentPlayer]--;
        -: 1316:    }
        -: 1317:	
    32086: 1318:  return 0;
        -: 1319:}
        -: 1320:
function gainCard called 26359 returned 100% blocks executed 100%
    26359: 1321:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1322:{
        -: 1323:  //Note: supplyPos is enum of choosen card
        -: 1324:	
        -: 1325:  //check if supply pile is empty (0) or card is not used in game (-1)
    26359: 1326:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 26359
branch  1 taken 163 (fallthrough)
branch  2 taken 26196
        -: 1327:    {
      163: 1328:      return -1;
        -: 1329:    }
        -: 1330:	
        -: 1331:  //added card for [whoseTurn] current player:
        -: 1332:  // toFlag = 0 : add to discard
        -: 1333:  // toFlag = 1 : add to deck
        -: 1334:  // toFlag = 2 : add to hand
        -: 1335:
    26196: 1336:  if (toFlag == 1)
branch  0 taken 1348 (fallthrough)
branch  1 taken 24848
        -: 1337:    {
        -: 1338:      //assert(state->deckCount[player] < MAX_DECK);
     1348: 1339:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
     1348: 1340:      state->deckCount[player]++;
        -: 1341:    }
    24848: 1342:  else if (toFlag == 2)
branch  0 taken 38 (fallthrough)
branch  1 taken 24810
        -: 1343:    {
       38: 1344:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
       38: 1345:      state->handCount[player]++;
        -: 1346:    }
        -: 1347:  else
        -: 1348:    {
        -: 1349:      //assert(state->discardCount[player] < MAX_DECK);
    24810: 1350:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    24810: 1351:      state->discardCount[player]++;
        -: 1352:    }
        -: 1353:	
        -: 1354:  //decrease number in supply pile
    26196: 1355:  state->supplyCount[supplyPos]--;
        -: 1356:	 
    26196: 1357:  return 0;
        -: 1358:}
        -: 1359:
function updateCoins called 176751 returned 100% blocks executed 100%
   176751: 1360:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1361:{
        -: 1362:  int i;
        -: 1363:	
        -: 1364:  //reset coin count
   176751: 1365:  state->coins = 0;
        -: 1366:
        -: 1367:  //add coins for each Treasure card in player's hand
  1095397: 1368:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 918646
branch  1 taken 176751 (fallthrough)
        -: 1369:    {
   918646: 1370:      if (state->hand[player][i] == copper)
branch  0 taken 221357 (fallthrough)
branch  1 taken 697289
        -: 1371:	{
   221357: 1372:	  state->coins += 1;
        -: 1373:	}
   697289: 1374:      else if (state->hand[player][i] == silver)
branch  0 taken 7564 (fallthrough)
branch  1 taken 689725
        -: 1375:	{
     7564: 1376:	  state->coins += 2;
        -: 1377:	}
   689725: 1378:      else if (state->hand[player][i] == gold)
branch  0 taken 4920 (fallthrough)
branch  1 taken 684805
        -: 1379:	{
     4920: 1380:	  state->coins += 3;
        -: 1381:	}	
        -: 1382:    }	
        -: 1383:
        -: 1384:  //add bonus
   176751: 1385:  state->coins += bonus;
        -: 1386:
   176751: 1387:  return 0;
        -: 1388:}
        -: 1389:
        -: 1390:
        -: 1391://end of dominion.c
        -: 1392:
*** RANDOM TEST ADVENTURER ***
File 'dominion.c'
Lines executed:85.50% of 614
Branches executed:80.71% of 425
Taken at least once:76.71% of 425
Calls executed:92.63% of 95
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:3
        -:    0:Programs:3
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <assert.h>
        -:    5:#include <stdio.h>
        -:    6:#include <math.h>
        -:    7:#include <stdlib.h>
        -:    8:
function compare called 4617149 returned 100% blocks executed 100%
  4617149:    9:int compare(const void* a, const void* b) {
  4617149:   10:  if (*(int*)a > *(int*)b)
branch  0 taken 2213695 (fallthrough)
branch  1 taken 2403454
  2213695:   11:    return 1;
  2403454:   12:  if (*(int*)a < *(int*)b)
branch  0 taken 1350926 (fallthrough)
branch  1 taken 1052528
  1350926:   13:    return -1;
  1052528:   14:  return 0;
        -:   15:}
        -:   16:
function newGame called 0 returned 0% blocks executed 0%
    #####:   17:struct gameState* newGame() {
    #####:   18:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   19:  return g;
        -:   20:}
        -:   21:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   22:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   23:		  int k8, int k9, int k10) {
    #####:   24:  int* k = malloc(10 * sizeof(int));
    #####:   25:  k[0] = k1;
    #####:   26:  k[1] = k2;
    #####:   27:  k[2] = k3;
    #####:   28:  k[3] = k4;
    #####:   29:  k[4] = k5;
    #####:   30:  k[5] = k6;
    #####:   31:  k[6] = k7;
    #####:   32:  k[7] = k8;
    #####:   33:  k[8] = k9;
    #####:   34:  k[9] = k10;
    #####:   35:  return k;
        -:   36:}
        -:   37:
function initializeGame called 3000 returned 100% blocks executed 95%
     3000:   38:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   39:		   struct gameState *state) {
        -:   40:
        -:   41:  int i;
        -:   42:  int j;
        -:   43:  int it;			
        -:   44:  //set up random number generator
     3000:   45:  SelectStream(1);
call    0 returned 3000
     3000:   46:  PutSeed((long)randomSeed);
call    0 returned 3000
        -:   47:  
        -:   48:  //check number of players
     3000:   49:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 3000 (fallthrough)
branch  1 taken 0
branch  2 taken 1025 (fallthrough)
branch  3 taken 1975
        -:   50:    {
     1025:   51:      return -1;
        -:   52:    }
        -:   53:
        -:   54:  //set number of players
     1975:   55:  state->numPlayers = numPlayers;
        -:   56:
        -:   57:  //check selected kingdom cards are different
    21725:   58:  for (i = 0; i < 10; i++)
branch  0 taken 19750
branch  1 taken 1975 (fallthrough)
        -:   59:    {
   217250:   60:      for (j = 0; j < 10; j++)
branch  0 taken 197500
branch  1 taken 19750 (fallthrough)
        -:   61:        {
   197500:   62:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 177750 (fallthrough)
branch  1 taken 19750
branch  2 taken 0 (fallthrough)
branch  3 taken 177750
        -:   63:	    {
    #####:   64:	      return -1;
        -:   65:	    }
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:  //initialize supply
        -:   71:  ///////////////////////////////
        -:   72:
        -:   73:  //set number of Curse cards
     1975:   74:  if (numPlayers == 2)
branch  0 taken 998 (fallthrough)
branch  1 taken 977
        -:   75:    {
      998:   76:      state->supplyCount[curse] = 10;
        -:   77:    }
      977:   78:  else if (numPlayers == 3)
branch  0 taken 977 (fallthrough)
branch  1 taken 0
        -:   79:    {
      977:   80:      state->supplyCount[curse] = 20;
        -:   81:    }
        -:   82:  else
        -:   83:    {
    #####:   84:      state->supplyCount[curse] = 30;
        -:   85:    }
        -:   86:
        -:   87:  //set number of Victory cards
     1975:   88:  if (numPlayers == 2)
branch  0 taken 998 (fallthrough)
branch  1 taken 977
        -:   89:    {
      998:   90:      state->supplyCount[estate] = 8;
      998:   91:      state->supplyCount[duchy] = 8;
      998:   92:      state->supplyCount[province] = 8;
        -:   93:    }
        -:   94:  else
        -:   95:    {
      977:   96:      state->supplyCount[estate] = 12;
      977:   97:      state->supplyCount[duchy] = 12;
      977:   98:      state->supplyCount[province] = 12;
        -:   99:    }
        -:  100:
        -:  101:  //set number of Treasure cards
     1975:  102:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     1975:  103:  state->supplyCount[silver] = 40;
     1975:  104:  state->supplyCount[gold] = 30;
        -:  105:
        -:  106:  //set number of Kingdom cards
    41475:  107:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 39500
branch  1 taken 1975 (fallthrough)
        -:  108:    {
   325875:  109:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 306125
branch  1 taken 19750 (fallthrough)
        -:  110:	{
   306125:  111:	  if (kingdomCards[j] == i)
branch  0 taken 19750 (fallthrough)
branch  1 taken 286375
        -:  112:	    {
        -:  113:	      //check if card is a 'Victory' Kingdom card
    19750:  114:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 19750 (fallthrough)
branch  1 taken 0
branch  2 taken 1975 (fallthrough)
branch  3 taken 17775
        -:  115:		{
     3950:  116:		  if (numPlayers == 2){ 
branch  0 taken 998 (fallthrough)
branch  1 taken 977
      998:  117:		    state->supplyCount[i] = 8; 
        -:  118:		  }
      977:  119:		  else{ state->supplyCount[i] = 12; }
        -:  120:		}
        -:  121:	      else
        -:  122:		{
    17775:  123:		  state->supplyCount[i] = 10;
        -:  124:		}
    19750:  125:	      break;
        -:  126:	    }
        -:  127:	  else    //card is not in the set choosen for the game
        -:  128:	    {
   286375:  129:	      state->supplyCount[i] = -1;
        -:  130:	    }
        -:  131:	}
        -:  132:
        -:  133:    }
        -:  134:
        -:  135:  ////////////////////////
        -:  136:  //supply intilization complete
        -:  137:
        -:  138:  //set player decks
     6902:  139:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4927
branch  1 taken 1975 (fallthrough)
        -:  140:    {
     4927:  141:      state->deckCount[i] = 0;
    19708:  142:      for (j = 0; j < 3; j++)
branch  0 taken 14781
branch  1 taken 4927 (fallthrough)
        -:  143:	{
    14781:  144:	  state->deck[i][j] = estate;
    14781:  145:	  state->deckCount[i]++;
        -:  146:	}
    39416:  147:      for (j = 3; j < 10; j++)
branch  0 taken 34489
branch  1 taken 4927 (fallthrough)
        -:  148:	{
    34489:  149:	  state->deck[i][j] = copper;
    34489:  150:	  state->deckCount[i]++;		
        -:  151:	}
        -:  152:    }
        -:  153:
        -:  154:  //shuffle player decks
     6902:  155:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4927
branch  1 taken 1975 (fallthrough)
        -:  156:    {
     4927:  157:      if ( shuffle(i, state) < 0 )
call    0 returned 4927
branch  1 taken 0 (fallthrough)
branch  2 taken 4927
        -:  158:	{
    #####:  159:	  return -1;
        -:  160:	}
        -:  161:    }
        -:  162:
        -:  163:  //draw player hands
     6902:  164:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4927
branch  1 taken 1975 (fallthrough)
        -:  165:    {  
        -:  166:      //initialize hand size to zero
     4927:  167:      state->handCount[i] = 0;
     4927:  168:      state->discardCount[i] = 0;
        -:  169:      //draw 5 cards
        -:  170:      // for (j = 0; j < 5; j++)
        -:  171:      //	{
        -:  172:      //	  drawCard(i, state);
        -:  173:      //	}
        -:  174:    }
        -:  175:  
        -:  176:  //set embargo tokens to 0 for all supply piles
    55300:  177:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 53325
branch  1 taken 1975 (fallthrough)
        -:  178:    {
    53325:  179:      state->embargoTokens[i] = 0;
        -:  180:    }
        -:  181:
        -:  182:  //initialize first player's turn
     1975:  183:  state->outpostPlayed = 0;
     1975:  184:  state->phase = 0;
     1975:  185:  state->numActions = 1;
     1975:  186:  state->numBuys = 1;
     1975:  187:  state->playedCardCount = 0;
     1975:  188:  state->whoseTurn = 0;
     1975:  189:  state->handCount[state->whoseTurn] = 0;
        -:  190:  //int it; move to top
        -:  191:
        -:  192:  //Moved draw cards to here, only drawing at the start of a turn
    11850:  193:  for (it = 0; it < 5; it++){
branch  0 taken 9875
branch  1 taken 1975 (fallthrough)
     9875:  194:    drawCard(state->whoseTurn, state);
call    0 returned 9875
        -:  195:  }
        -:  196:
     1975:  197:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 1975
        -:  198:
     1975:  199:  return 0;
        -:  200:}
        -:  201:
function shuffle called 75022 returned 100% blocks executed 100%
    75022:  202:int shuffle(int player, struct gameState *state) {
        -:  203: 
        -:  204:
        -:  205:  int newDeck[MAX_DECK * 2];
    75022:  206:  int newDeckPos = 0;
        -:  207:  int card;
        -:  208:  int i;
        -:  209:
    75022:  210:  if (state->deckCount[player] < 1)
branch  0 taken 14269 (fallthrough)
branch  1 taken 60753
    14269:  211:    return -1;
    60753:  212:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 60753
        -:  213:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  214:
        -:  215:  //assert(state->deckCount[player] <= MAX_DECK);
  1454579:  216:  while (state->deckCount[player] > 0) {
branch  0 taken 1333073
branch  1 taken 60753 (fallthrough)
  1333073:  217:    card = floor(Random() * state->deckCount[player]);
call    0 returned 1333073
  1333073:  218:    newDeck[newDeckPos] = state->deck[player][card];
  1333073:  219:    newDeckPos++;
 11430185:  220:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 10097112
branch  1 taken 1333073 (fallthrough)
 10097112:  221:      state->deck[player][i] = state->deck[player][i+1];
        -:  222:    }
  1333073:  223:    state->deckCount[player]--;
        -:  224:  }
  1393826:  225:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 1333073
branch  1 taken 60753 (fallthrough)
  1333073:  226:    state->deck[player][i] = newDeck[i];
  1333073:  227:    state->deckCount[player]++;
        -:  228:  }
        -:  229:
    60753:  230:  return 0;
        -:  231:}
        -:  232:
function playCard called 198687 returned 100% blocks executed 100%
   198687:  233:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  234:{	
        -:  235:  int card;
   198687:  236:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  237:
        -:  238:  //check if it is the right phase
   198687:  239:  if (state->phase != 0)
branch  0 taken 27255 (fallthrough)
branch  1 taken 171432
        -:  240:    {
    27255:  241:      return -1;
        -:  242:    }
        -:  243:	
        -:  244:  //check if player has enough actions
   171432:  245:  if ( state->numActions < 1 )
branch  0 taken 31544 (fallthrough)
branch  1 taken 139888
        -:  246:    {
    31544:  247:      return -1;
        -:  248:    }
        -:  249:	
        -:  250:  //get card played
   139888:  251:  card = handCard(handPos, state);
call    0 returned 139888
        -:  252:	
        -:  253:  //check if selected card is an action
   139888:  254:  if ( card < adventurer || card > treasure_map )
branch  0 taken 72650 (fallthrough)
branch  1 taken 67238
branch  2 taken 0 (fallthrough)
branch  3 taken 72650
        -:  255:    {
    67238:  256:      return -1;
        -:  257:    }
        -:  258:	
        -:  259:  //play card
    72650:  260:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 returned 72650
branch  1 taken 18899 (fallthrough)
branch  2 taken 53751
        -:  261:    {
    18899:  262:      return -1;
        -:  263:    }
        -:  264:	
        -:  265:  //reduce number of actions
    53751:  266:  state->numActions--;
        -:  267:
        -:  268:  //update coins (Treasure cards may be added with card draws)
    53751:  269:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 returned 53751
        -:  270:	
    53751:  271:  return 0;
        -:  272:}
        -:  273:
function buyCard called 198756 returned 100% blocks executed 100%
   198756:  274:int buyCard(int supplyPos, struct gameState *state) {
        -:  275:  int who;
        -:  276:  if (DEBUG){
        -:  277:    printf("Entering buyCard...\n");
        -:  278:  }
        -:  279:
        -:  280:  // I don't know what to do about the phase thing.
        -:  281:
   198756:  282:  who = state->whoseTurn;
        -:  283:
   198756:  284:  if (state->numBuys < 1){
branch  0 taken 25924 (fallthrough)
branch  1 taken 172832
        -:  285:    if (DEBUG)
        -:  286:      printf("You do not have any buys left\n");
    25924:  287:    return -1;
   172832:  288:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 172832
branch  1 taken 52201 (fallthrough)
branch  2 taken 120631
        -:  289:    if (DEBUG)
        -:  290:      printf("There are not any of that type of card left\n");
    52201:  291:    return -1;
   120631:  292:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 120631
branch  1 taken 92751 (fallthrough)
branch  2 taken 27880
        -:  293:    if (DEBUG) 
        -:  294:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    92751:  295:    return -1;
        -:  296:  } else {
    27880:  297:    state->phase=1;
        -:  298:    //state->supplyCount[supplyPos]--;
    27880:  299:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 27880
        -:  300:  
    27880:  301:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 27880
    27880:  302:    state->numBuys--;
        -:  303:    if (DEBUG)
        -:  304:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  305:  }
        -:  306:
        -:  307:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  308:  //state->discardCount[who]++;
        -:  309:    
    27880:  310:  return 0;
        -:  311:}
        -:  312:
function numHandCards called 401120 returned 100% blocks executed 100%
   401120:  313:int numHandCards(struct gameState *state) {
   401120:  314:  return state->handCount[ whoseTurn(state) ];
call    0 returned 401120
        -:  315:}
        -:  316:
function handCard called 1309067 returned 100% blocks executed 100%
  1309067:  317:int handCard(int handPos, struct gameState *state) {
  1309067:  318:  int currentPlayer = whoseTurn(state);
call    0 returned 1309067
  1309067:  319:  return state->hand[currentPlayer][handPos];
        -:  320:}
        -:  321:
function supplyCount called 223798 returned 100% blocks executed 100%
   223798:  322:int supplyCount(int card, struct gameState *state) {
   223798:  323:  return state->supplyCount[card];
        -:  324:}
        -:  325:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  326:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  327:  int i;
    #####:  328:  int count = 0;
        -:  329:
    #####:  330:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  331:    {
    #####:  332:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  333:    }
        -:  334:
    #####:  335:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  336:    {
    #####:  337:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  338:    }
        -:  339:
    #####:  340:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  341:    {
    #####:  342:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  343:    }
        -:  344:
    #####:  345:  return count;
        -:  346:}
        -:  347:
function whoseTurn called 2197657 returned 100% blocks executed 100%
  2197657:  348:int whoseTurn(struct gameState *state) {
  2197657:  349:  return state->whoseTurn;
        -:  350:}
        -:  351:
function endTurn called 198537 returned 100% blocks executed 100%
   198537:  352:int endTurn(struct gameState *state) {
        -:  353:  int k;
        -:  354:  int i;
   198537:  355:  int currentPlayer = whoseTurn(state);
call    0 returned 198537
        -:  356:  
        -:  357:  //Discard hand
  1404700:  358:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 1206163
branch  1 taken 198537 (fallthrough)
        -:  359:    //assert(state->discardCount[currentPlayer] < MAX_DECK);
  1206163:  360:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
  1206163:  361:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:  }
   198537:  363:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:    
        -:  365:  //Code for determining the player
   198537:  366:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 115548 (fallthrough)
branch  1 taken 82989
   115548:  367:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:  }
        -:  369:  else{
    82989:  370:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:  }
        -:  372:
   198537:  373:  state->outpostPlayed = 0;
   198537:  374:  state->phase = 0;
   198537:  375:  state->numActions = 1;
   198537:  376:  state->coins = 0;
   198537:  377:  state->numBuys = 1;
   198537:  378:  state->playedCardCount = 0;
   198537:  379:  state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:  //int k; move to top
        -:  382:  //Next player draws hand
  1191222:  383:  for (k = 0; k < 5; k++){
branch  0 taken 992685
branch  1 taken 198537 (fallthrough)
   992685:  384:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 992685
        -:  385:  }
        -:  386:
        -:  387:  //Update money
   198537:  388:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 198537
        -:  389:
   198537:  390:  return 0;
        -:  391:}
        -:  392:
function isGameOver called 997029 returned 100% blocks executed 91%
   997029:  393:int isGameOver(struct gameState *state) {
        -:  394:  int i;
        -:  395:  int j;
        -:  396:	
        -:  397:  //if stack of Province cards is empty, the game ends
   997029:  398:  if (state->supplyCount[province] == 0)
branch  0 taken 1024 (fallthrough)
branch  1 taken 996005
        -:  399:    {
     1024:  400:      return 1;
        -:  401:    }
        -:  402:
        -:  403:  //if three supply pile are at 0, the game ends
   996005:  404:  j = 0;
 25896130:  405:  for (i = 0; i < 25; i++)
branch  0 taken 24900125
branch  1 taken 996005 (fallthrough)
        -:  406:    {
 24900125:  407:      if (state->supplyCount[i] == 0)
branch  0 taken 67521 (fallthrough)
branch  1 taken 24832604
        -:  408:	{
    67521:  409:	  j++;
        -:  410:	}
        -:  411:    }
   996005:  412:  if ( j >= 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 996005
        -:  413:    {
    #####:  414:      return 1;
        -:  415:    }
        -:  416:
   996005:  417:  return 0;
        -:  418:}
        -:  419:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  420:int scoreFor (int player, struct gameState *state) {
        -:  421:
        -:  422:  int i;
    #####:  423:  int score = 0;
        -:  424:  //score from hand
    #####:  425:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  426:    {
    #####:  427:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  430:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  431:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  432:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  433:    }
        -:  434:
        -:  435:  //score from discard
    #####:  436:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  437:    {
    #####:  438:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  441:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  442:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  443:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  444:    }
        -:  445:
        -:  446:  //score from deck
    #####:  447:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  448:    {
    #####:  449:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  452:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  453:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  454:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  455:    }
        -:  456:
    #####:  457:  return score;
        -:  458:}
        -:  459:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:  int i;	
        -:  462:  int j;
        -:  463:  int highScore;
        -:  464:  int currentPlayer;
        -:  465:
        -:  466:  //get score for each player
    #####:  467:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  468:    {
        -:  469:      //set unused player scores to -9999
    #####:  470:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  471:	{
    #####:  472:	  players[i] = -9999;
        -:  473:	}
        -:  474:      else
        -:  475:	{
    #####:  476:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  477:	}
        -:  478:    }
        -:  479:
        -:  480:  //find highest score
    #####:  481:  j = 0;
    #####:  482:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  483:    {
    #####:  484:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  485:	{
    #####:  486:	  j = i;
        -:  487:	}
        -:  488:    }
    #####:  489:  highScore = players[j];
        -:  490:
        -:  491:  //add 1 to players who had less turns
    #####:  492:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  493:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  494:    {
    #####:  495:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  496:	{
    #####:  497:	  players[i]++;
        -:  498:	}
        -:  499:    }
        -:  500:
        -:  501:  //find new highest score
    #####:  502:  j = 0;
    #####:  503:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  504:    {
    #####:  505:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  506:	{
    #####:  507:	  j = i;
        -:  508:	}
        -:  509:    }
    #####:  510:  highScore = players[j];
        -:  511:
        -:  512:  //set winners in array to 1 and rest to 0
    #####:  513:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  514:    {
    #####:  515:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  516:	{
    #####:  517:	  players[i] = 1;
        -:  518:	}
        -:  519:      else
        -:  520:	{
    #####:  521:	  players[i] = 0;
        -:  522:	}
        -:  523:    }
        -:  524:
    #####:  525:  return 0;
        -:  526:}
        -:  527:
function drawCard called 1215115 returned 100% blocks executed 100%
  1215115:  528:int drawCard(int player, struct gameState *state)
        -:  529:{	int count;
        -:  530:  int deckCounter;
  1215115:  531:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 60399 (fallthrough)
branch  1 taken 1154716
        -:  532:    
        -:  533:    //Step 1 Shuffle the discard pile back into a deck
        -:  534:    int i;
        -:  535:    //Move discard to deck
  1340976:  536:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 1280577
branch  1 taken 60399 (fallthrough)
  1280577:  537:      state->deck[player][i] = state->discard[player][i];
  1280577:  538:      state->discard[player][i] = -1;
        -:  539:    }
        -:  540:
        -:  541:    //assert(state->discardCount[player] <= MAX_DECK);
    60399:  542:    state->deckCount[player] = state->discardCount[player];
    60399:  543:    state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:    //Shufffle the deck
    60399:  546:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 60399
        -:  547:   
        -:  548:    if (DEBUG){//Debug statements
        -:  549:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:    }
        -:  551:    
    60399:  552:    state->discardCount[player] = 0;
        -:  553:
        -:  554:    //Step 2 Draw Card
    60399:  555:    count = state->handCount[player];//Get current player's hand count
        -:  556:    
        -:  557:    if (DEBUG){//Debug statements
        -:  558:      printf("Current hand count: %d\n", count);
        -:  559:    }
        -:  560:    
    60399:  561:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
    60399:  563:    if (deckCounter == 0)
branch  0 taken 4821 (fallthrough)
branch  1 taken 55578
     4821:  564:      return -1;
        -:  565:
    55578:  566:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    55578:  567:    state->deckCount[player]--;
    55578:  568:    state->handCount[player]++;//Increment hand count
        -:  569:  }
        -:  570:
        -:  571:  else{
  1154716:  572:    int count = state->handCount[player];//Get current hand count for player
        -:  573:    int deckCounter;
        -:  574:    if (DEBUG){//Debug statements
        -:  575:      printf("Current hand count: %d\n", count);
        -:  576:    }
        -:  577:
  1154716:  578:    deckCounter = state->deckCount[player];//Create holder for the deck count
  1154716:  579:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
  1154716:  580:    state->deckCount[player]--;
  1154716:  581:    state->handCount[player]++;//Increment hand count
        -:  582:  }
        -:  583:
  1210294:  584:  return 0;
        -:  585:}
        -:  586:
function getCost called 164342 returned 100% blocks executed 100%
   164342:  587:int getCost(int cardNumber)
        -:  588:{
   164342:  589:  switch( cardNumber ) 
branch  0 taken 18817
branch  1 taken 13590
branch  2 taken 10187
branch  3 taken 9993
branch  4 taken 20091
branch  5 taken 11378
branch  6 taken 8911
branch  7 taken 9088
branch  8 taken 152
branch  9 taken 109
branch 10 taken 9748
branch 11 taken 9284
branch 12 taken 849
branch 13 taken 9969
branch 14 taken 10795
branch 15 taken 169
branch 16 taken 132
branch 17 taken 9246
branch 18 taken 142
branch 19 taken 9283
branch 20 taken 212
branch 21 taken 342
branch 22 taken 337
branch 23 taken 132
branch 24 taken 574
branch 25 taken 378
branch 26 taken 162
branch 27 taken 272
        -:  590:    {
    18817:  591:    case curse:
    18817:  592:      return 0;
    13590:  593:    case estate:
    13590:  594:      return 2;
    10187:  595:    case duchy:
    10187:  596:      return 5;
     9993:  597:    case province:
     9993:  598:      return 8;
    20091:  599:    case copper:
    20091:  600:      return 0;
    11378:  601:    case silver:
    11378:  602:      return 3;
     8911:  603:    case gold:
     8911:  604:      return 6;
     9088:  605:    case adventurer:
     9088:  606:      return 6;
      152:  607:    case council_room:
      152:  608:      return 5;
      109:  609:    case feast:
      109:  610:      return 4;
     9748:  611:    case gardens:
     9748:  612:      return 4;
     9284:  613:    case mine:
     9284:  614:      return 5;
      849:  615:    case remodel:
      849:  616:      return 4;
     9969:  617:    case smithy:
     9969:  618:      return 4;
    10795:  619:    case village:
    10795:  620:      return 3;
      169:  621:    case baron:
      169:  622:      return 4;
      132:  623:    case great_hall:
      132:  624:      return 3;
     9246:  625:    case minion:
     9246:  626:      return 5;
      142:  627:    case steward:
      142:  628:      return 3;
     9283:  629:    case tribute:
     9283:  630:      return 5;
      212:  631:    case ambassador:
      212:  632:      return 3;
      342:  633:    case cutpurse:
      342:  634:      return 4;
      337:  635:    case embargo: 
      337:  636:      return 2;
      132:  637:    case outpost:
      132:  638:      return 5;
      574:  639:    case salvager:
      574:  640:      return 4;
      378:  641:    case sea_hag:
      378:  642:      return 4;
      162:  643:    case treasure_map:
      162:  644:      return 4;
        -:  645:    }
        -:  646:	
      272:  647:  return -1;
        -:  648:}
        -:  649:
function adventurerCardEffect called 13634 returned 100% blocks executed 100%
    13634:  650:int adventurerCardEffect(struct gameState *state, int currentPlayer)
        -:  651:{
    13634:  652:  int drawntreasure = 0;
        -:  653:  int cardDrawn;
    13634:  654:  int z = 0;// this is the counter for the temp hand
        -:  655:  int temphand[MAX_HAND * 2];
        -:  656:
   190632:  657:  while(drawntreasure<2 && z<MAX_HAND){
branch  0 taken 163444 (fallthrough)
branch  1 taken 13554
branch  2 taken 163444
branch  3 taken 0 (fallthrough)
   163444:  658:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 9448 (fallthrough)
branch  1 taken 153996
     9448:  659:      shuffle(currentPlayer, state);
call    0 returned 9448
        -:  660:    }
   163444:  661:    drawCard(currentPlayer, state);
call    0 returned 163444
   163444:  662:    if (state->handCount[currentPlayer] <= 0) {
branch  0 taken 80 (fallthrough)
branch  1 taken 163364
       80:  663:      break;
        -:  664:    }
   163364:  665:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
   163364:  666:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 138062 (fallthrough)
branch  1 taken 25302
branch  2 taken 136921 (fallthrough)
branch  3 taken 1141
branch  4 taken 665 (fallthrough)
branch  5 taken 136256
    27108:  667:      drawntreasure++;
        -:  668:    else{
   136256:  669:      temphand[z]=cardDrawn;
   136256:  670:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
   136256:  671:      z++;
        -:  672:    }
        -:  673:  }
   163524:  674:  while(z-1>=0){
branch  0 taken 136256
branch  1 taken 13634 (fallthrough)
        -:  675:    //assert(state->discardCount[currentPlayer] < MAX_DECK);
   136256:  676:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
   136256:  677:    z=z-1;
        -:  678:  }
    13634:  679:  return 0;
        -:  680:}
        -:  681:
function smithyCardEffect called 3308 returned 100% blocks executed 100%
     3308:  682:int smithyCardEffect(struct gameState *state, int handPos, int currentPlayer)
        -:  683:{
        -:  684:  int i;
        -:  685:
        -:  686:  //+3 Cards
    13232:  687:  for (i = 0; i < 3; i++)
branch  0 taken 9924
branch  1 taken 3308 (fallthrough)
        -:  688:    {
     9924:  689:      drawCard(currentPlayer, state);
call    0 returned 9924
        -:  690:    }
        -:  691:
        -:  692:  //discard card from hand
     3308:  693:  discardCard(handPos, currentPlayer, state, 1);
call    0 returned 3308
     3308:  694:  return 0;
        -:  695:}
        -:  696:
function councilRoomCardEffect called 4814 returned 100% blocks executed 100%
     4814:  697:int councilRoomCardEffect(struct gameState *state, int handPos, int currentPlayer)
        -:  698:{
        -:  699:  int i;
        -:  700:
        -:  701:  //+4 Cards
    24070:  702:  for (i = 0; i < 4; i++)
branch  0 taken 19256
branch  1 taken 4814 (fallthrough)
        -:  703:    {
    19256:  704:      drawCard(currentPlayer, state);
call    0 returned 19256
        -:  705:    }
        -:  706:
        -:  707:  //+1 Buy
     4814:  708:  state->numBuys++;
        -:  709:
        -:  710:  //Each other player draws a card
    16779:  711:  for (i = 0; i < state->numPlayers; i++)
branch  0 taken 11965
branch  1 taken 4814 (fallthrough)
        -:  712:    {
    11965:  713:      if ( i != currentPlayer )
branch  0 taken 7151 (fallthrough)
branch  1 taken 4814
        -:  714:        {
     7151:  715:          drawCard(i, state);
call    0 returned 7151
        -:  716:        }
        -:  717:    }
        -:  718:
        -:  719:  //put played card in played card pile
     4814:  720:  discardCard(handPos, currentPlayer, state, 0);
call    0 returned 4814
        -:  721:
     4814:  722:  return 0;
        -:  723:}
        -:  724:
function feastCardEffect called 7100 returned 100% blocks executed 100%
     7100:  725:int feastCardEffect(struct gameState *state, int choice1, int currentPlayer)
        -:  726:{
        -:  727:  int i;
        -:  728:  int x;
        -:  729:  int temphand[MAX_HAND * 2];
        -:  730:
        -:  731:  //gain card with cost up to 5
        -:  732:  //Backup hand
     7100:  733:  int hc = MAX_HAND;
     7100:  734:  if (state->handCount[currentPlayer] < hc) {
branch  0 taken 7100 (fallthrough)
branch  1 taken 0
     7100:  735:    hc = state->handCount[currentPlayer];
        -:  736:  }
    52393:  737:  for (i = 0; i < hc; i++){
branch  0 taken 45293
branch  1 taken 7100 (fallthrough)
    45293:  738:    temphand[i] = state->hand[currentPlayer][i];//Backup card
    45293:  739:    state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  740:  }
        -:  741:  //Backup hand
        -:  742:
        -:  743:  //Update Coins for Buy
     7100:  744:  updateCoins(currentPlayer, state, 5);
call    0 returned 7100
     7100:  745:  x = 1;//Condition to loop on
    18336:  746:  while( x == 1) {//Buy one card
branch  0 taken 7100
branch  1 taken 4136 (fallthrough)
     7100:  747:    if (supplyCount(choice1, state) <= 0){
call    0 returned 7100
branch  1 taken 2119 (fallthrough)
branch  2 taken 4981
        -:  748:      if (DEBUG)
        -:  749:        printf("None of that card left, sorry!\n");
        -:  750:
        -:  751:      if (DEBUG){
        -:  752:        printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  753:      }
     2119:  754:      return 1;
        -:  755:    }
     4981:  756:    else if (state->coins < getCost(choice1)){
call    0 returned 4981
branch  1 taken 845 (fallthrough)
branch  2 taken 4136
      845:  757:      printf("That card is too expensive!\n");
call    0 returned 845
        -:  758:
        -:  759:      if (DEBUG){
        -:  760:        printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  761:      }
      845:  762:      return 1;
        -:  763:    }
        -:  764:    else{
        -:  765:
        -:  766:      if (DEBUG){
        -:  767:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  768:      }
        -:  769:
     4136:  770:      gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 returned 4136
     4136:  771:      x = 0;//No more buying cards
        -:  772:
        -:  773:      if (DEBUG){
        -:  774:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  775:      }
        -:  776:
        -:  777:    }
        -:  778:  }
        -:  779:
        -:  780:  //Reset Hand
    29832:  781:  for (i = 0; i < hc; i++){
branch  0 taken 25696
branch  1 taken 4136 (fallthrough)
    25696:  782:    state->hand[currentPlayer][i] = temphand[i];
    25696:  783:    temphand[i] = -1;
        -:  784:  }
        -:  785:  //Reset Hand
        -:  786:
     4136:  787:  return 0;
        -:  788:}
        -:  789:
function mineCardEffect called 4521 returned 100% blocks executed 95%
     4521:  790:int mineCardEffect(struct gameState *state, int choice1, int choice2, int handPos, int currentPlayer)
        -:  791:{
        -:  792:  int i;
        -:  793:  int j;
        -:  794:
     4521:  795:  if (choice1 > state->numPlayers) {
branch  0 taken 1761 (fallthrough)
branch  1 taken 2760
     1761:  796:    return -1;
        -:  797:  }
     2760:  798:  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  799:
     2760:  800:  if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 taken 565 (fallthrough)
branch  1 taken 2195
branch  2 taken 339 (fallthrough)
branch  3 taken 226
        -:  801:    {
     2534:  802:      return -1;
        -:  803:    }
        -:  804:
      226:  805:  if (choice2 > treasure_map || choice2 < curse)
branch  0 taken 226 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 226
        -:  806:    {
    #####:  807:      return -1;
        -:  808:    }
        -:  809:
      226:  810:  if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 returned 226
call    1 returned 226
branch  2 taken 171 (fallthrough)
branch  3 taken 55
        -:  811:    {
      171:  812:      return -1;
        -:  813:    }
        -:  814:
       55:  815:  gainCard(choice2, state, 2, currentPlayer);
call    0 returned 55
        -:  816:
        -:  817:  //discard card from hand
       55:  818:  discardCard(handPos, currentPlayer, state, 0);
call    0 returned 55
        -:  819:
        -:  820:  //discard trashed card
      270:  821:  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 249
branch  1 taken 21 (fallthrough)
        -:  822:    {
      249:  823:      if (state->hand[currentPlayer][i] == j)
branch  0 taken 34 (fallthrough)
branch  1 taken 215
        -:  824:        {
       34:  825:          discardCard(i, currentPlayer, state, 0);
call    0 returned 34
       34:  826:          break;
        -:  827:        }
        -:  828:    }
        -:  829:
       55:  830:  return 0;
        -:  831:}
        -:  832:
function cardEffect called 72650 returned 100% blocks executed 93%
    72650:  833:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  834:{
        -:  835:  int i;
        -:  836:  int j;
        -:  837:  int k;
        -:  838:  int index;
    72650:  839:  int currentPlayer = whoseTurn(state);
call    0 returned 72650
    72650:  840:  int nextPlayer = currentPlayer + 1;
        -:  841:
    72650:  842:  int tributeRevealedCards[2] = {-1, -1};
    72650:  843:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 taken 30520 (fallthrough)
branch  1 taken 42130
    30520:  844:    nextPlayer = 0;
        -:  845:  }
        -:  846:  
        -:  847:	
        -:  848:  //uses switch to select card and perform actions
    72650:  849:  switch( card ) 
branch  0 taken 4061
branch  1 taken 2299
branch  2 taken 2995
branch  3 taken 4959
branch  4 taken 4521
branch  5 taken 3883
branch  6 taken 3308
branch  7 taken 3857
branch  8 taken 3974
branch  9 taken 3041
branch 10 taken 3233
branch 11 taken 3151
branch 12 taken 4797
branch 13 taken 4210
branch 14 taken 3062
branch 15 taken 3032
branch 16 taken 3038
branch 17 taken 3191
branch 18 taken 4112
branch 19 taken 3926
branch 20 taken 0
        -:  850:    {
     4061:  851:    case adventurer:
     4061:  852:      return adventurerCardEffect(state, currentPlayer);
call    0 returned 4061
        -:  853:			
     2299:  854:    case council_room:
     2299:  855:      return councilRoomCardEffect(state, handPos, currentPlayer);
call    0 returned 2299
        -:  856:			
     2995:  857:    case feast:
     2995:  858:      return feastCardEffect(state, choice1, currentPlayer);
call    0 returned 2995
        -:  859:			
     4959:  860:    case gardens:
     4959:  861:      return -1;
        -:  862:			
     4521:  863:    case mine:
     4521:  864:      return mineCardEffect(state, choice1, choice2, currentPlayer, handPos);
call    0 returned 4521
        -:  865:			
     3883:  866:    case remodel:
     3883:  867:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  868:
     3883:  869:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 returned 3883
call    1 returned 3883
branch  2 taken 2526 (fallthrough)
branch  3 taken 1357
        -:  870:	{
     2526:  871:	  return -1;
        -:  872:	}
        -:  873:
     1357:  874:      gainCard(choice2, state, 0, currentPlayer);
call    0 returned 1357
        -:  875:
        -:  876:      //discard card from hand
     1357:  877:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 1357
        -:  878:
        -:  879:      //discard trashed card
     3750:  880:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 3639
branch  1 taken 111 (fallthrough)
        -:  881:	{
     3639:  882:	  if (state->hand[currentPlayer][i] == j)
branch  0 taken 1246 (fallthrough)
branch  1 taken 2393
        -:  883:	    {
     1246:  884:	      discardCard(i, currentPlayer, state, 0);			
call    0 returned 1246
     1246:  885:	      break;
        -:  886:	    }
        -:  887:	}
        -:  888:
        -:  889:
     1357:  890:      return 0;
        -:  891:		
     3308:  892:    case smithy:
     3308:  893:      return smithyCardEffect(state, handPos, currentPlayer);
call    0 returned 3308
        -:  894:		
     3857:  895:    case village:
        -:  896:      //+1 Card
     3857:  897:      drawCard(currentPlayer, state);
call    0 returned 3857
        -:  898:			
        -:  899:      //+2 Actions
     3857:  900:      state->numActions = state->numActions + 2;
        -:  901:			
        -:  902:      //discard played card from hand
     3857:  903:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 3857
     3857:  904:      return 0;
        -:  905:		
     3974:  906:    case baron:
     3974:  907:      state->numBuys++;//Increase buys by 1!
     3974:  908:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 taken 3254 (fallthrough)
branch  1 taken 720
     3254:  909:	int p = 0;//Iterator for hand!
     3254:  910:	int card_not_discarded = 1;//Flag for discard set!
    25373:  911:	while(card_not_discarded){
branch  0 taken 18865
branch  1 taken 3254 (fallthrough)
    18865:  912:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 taken 1300 (fallthrough)
branch  1 taken 17565
     1300:  913:	    state->coins += 4;//Add 4 coins to the amount of coins
        -:  914:	    //assert(state->discardCount[currentPlayer] < MAX_DECK);
     1300:  915:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
     1300:  916:	    state->discardCount[currentPlayer]++;
     6764:  917:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 taken 5464
branch  1 taken 1300 (fallthrough)
     5464:  918:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  919:	    }
     1300:  920:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
     1300:  921:	    state->handCount[currentPlayer]--;
     1300:  922:	    card_not_discarded = 0;//Exit the loop
        -:  923:	  }
    17565:  924:	  else if (p > state->handCount[currentPlayer]){
branch  0 taken 1954 (fallthrough)
branch  1 taken 15611
        -:  925:	    if(DEBUG) {
        -:  926:	      printf("No estate cards in your hand, invalid choice\n");
        -:  927:	      printf("Must gain an estate if there are any\n");
        -:  928:	    }
     1954:  929:	    if (supplyCount(estate, state) > 0){
call    0 returned 1954
branch  1 taken 1680 (fallthrough)
branch  2 taken 274
     1680:  930:	      gainCard(estate, state, 0, currentPlayer);
call    0 returned 1680
     1680:  931:	      state->supplyCount[estate]--;//Decrement estates
     1680:  932:	      if (supplyCount(estate, state) == 0){
call    0 returned 1680
branch  1 taken 110 (fallthrough)
branch  2 taken 1570
      110:  933:		isGameOver(state);
call    0 returned 110
        -:  934:	      }
        -:  935:	    }
     1954:  936:	    card_not_discarded = 0;//Exit the loop
        -:  937:	  }
        -:  938:			    
        -:  939:	  else{
    15611:  940:	    p++;//Next card
        -:  941:	  }
        -:  942:	}
        -:  943:      }
        -:  944:			    
        -:  945:      else{
      720:  946:	if (supplyCount(estate, state) > 0){
call    0 returned 720
branch  1 taken 651 (fallthrough)
branch  2 taken 69
      651:  947:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 returned 651
      651:  948:	  state->supplyCount[estate]--;//Decrement Estates
      651:  949:	  if (supplyCount(estate, state) == 0){
call    0 returned 651
branch  1 taken 35 (fallthrough)
branch  2 taken 616
       35:  950:	    isGameOver(state);
call    0 returned 35
        -:  951:	  }
        -:  952:	}
        -:  953:      }
        -:  954:	    
        -:  955:      
     3974:  956:      return 0;
        -:  957:		
     3041:  958:    case great_hall:
        -:  959:      //+1 Card
     3041:  960:      drawCard(currentPlayer, state);
call    0 returned 3041
        -:  961:			
        -:  962:      //+1 Actions
     3041:  963:      state->numActions++;
        -:  964:			
        -:  965:      //discard card from hand
     3041:  966:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 3041
     3041:  967:      return 0;
        -:  968:		
     3233:  969:    case minion:
        -:  970:      //+1 action
     3233:  971:      state->numActions++;
        -:  972:			
        -:  973:      //discard card from hand
     3233:  974:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 3233
        -:  975:			
     3233:  976:      if (choice1)		//+2 coins
branch  0 taken 2668 (fallthrough)
branch  1 taken 565
        -:  977:	{
     2668:  978:	  state->coins = state->coins + 2;
        -:  979:	}
        -:  980:			
      565:  981:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 taken 464 (fallthrough)
branch  1 taken 101
        -:  982:	{
        -:  983:	  //discard hand
     3107:  984:	  while(numHandCards(state) > 0)
call    0 returned 2643
branch  1 taken 2179
branch  2 taken 464 (fallthrough)
        -:  985:	    {
     2179:  986:	      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 2179
        -:  987:	    }
        -:  988:				
        -:  989:	  //draw 4
     2320:  990:	  for (i = 0; i < 4; i++)
branch  0 taken 1856
branch  1 taken 464 (fallthrough)
        -:  991:	    {
     1856:  992:	      drawCard(currentPlayer, state);
call    0 returned 1856
        -:  993:	    }
        -:  994:				
        -:  995:	  //other players discard hand and redraw if hand size > 4
     1623:  996:	  for (i = 0; i < state->numPlayers; i++)
branch  0 taken 1159
branch  1 taken 464 (fallthrough)
        -:  997:	    {
     1159:  998:	      if (i != currentPlayer)
branch  0 taken 695 (fallthrough)
branch  1 taken 464
        -:  999:		{
      695: 1000:		  if ( state->handCount[i] > 4 )
branch  0 taken 0 (fallthrough)
branch  1 taken 695
        -: 1001:		    {
        -: 1002:		      //discard hand
    #####: 1003:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1004:			{
    #####: 1005:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1006:			}
        -: 1007:							
        -: 1008:		      //draw 4
    #####: 1009:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1010:			{
    #####: 1011:			  drawCard(i, state);
call    0 never executed
        -: 1012:			}
        -: 1013:		    }
        -: 1014:		}
        -: 1015:	    }
        -: 1016:				
        -: 1017:	}
     3233: 1018:      return 0;
        -: 1019:		
     3151: 1020:    case steward:
     3151: 1021:      if (choice1 == 1)
branch  0 taken 588 (fallthrough)
branch  1 taken 2563
        -: 1022:	{
        -: 1023:	  //+2 cards
      588: 1024:	  drawCard(currentPlayer, state);
call    0 returned 588
      588: 1025:	  drawCard(currentPlayer, state);
call    0 returned 588
        -: 1026:	}
     2563: 1027:      else if (choice1 == 2)
branch  0 taken 559 (fallthrough)
branch  1 taken 2004
        -: 1028:	{
        -: 1029:	  //+2 coins
      559: 1030:	  state->coins = state->coins + 2;
        -: 1031:	}
        -: 1032:      else
        -: 1033:	{
        -: 1034:	  //trash 2 cards in hand
     2004: 1035:	  discardCard(choice2, currentPlayer, state, 1);
call    0 returned 2004
     2004: 1036:	  discardCard(choice3, currentPlayer, state, 1);
call    0 returned 2004
        -: 1037:	}
        -: 1038:			
        -: 1039:      //discard card from hand
     3151: 1040:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 3151
     3151: 1041:      return 0;
        -: 1042:		
     4797: 1043:    case tribute:
     4797: 1044:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 taken 1 (fallthrough)
branch  1 taken 4796
        1: 1045:	if (state->deckCount[nextPlayer] > 0){
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1046:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1047:	  state->deckCount[nextPlayer]--;
        -: 1048:	}
        1: 1049:	else if (state->discardCount[nextPlayer] > 0){
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1050:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1051:	  state->discardCount[nextPlayer]--;
        -: 1052:	}
        -: 1053:	else{
        -: 1054:	  //No Card to Reveal
        -: 1055:	  if (DEBUG){
        -: 1056:	    printf("No cards to reveal\n");
        -: 1057:	  }
        -: 1058:	}
        -: 1059:      }
        -: 1060:	    
        -: 1061:      else{
     4796: 1062:	if (state->deckCount[nextPlayer] == 0){
branch  0 taken 248 (fallthrough)
branch  1 taken 4548
     3474: 1063:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 taken 3226
branch  1 taken 248 (fallthrough)
     3226: 1064:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
        -: 1065:	    //assert(state->deckCount[nextPlayer] < MAX_DECK);
     3226: 1066:	    state->deckCount[nextPlayer]++;
     3226: 1067:	    state->discard[nextPlayer][i] = -1;
     3226: 1068:	    state->discardCount[nextPlayer]--;
        -: 1069:	  }
        -: 1070:			    
      248: 1071:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 returned 248
        -: 1072:	} 
     4796: 1073:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
     4796: 1074:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
     4796: 1075:	state->deckCount[nextPlayer]--;
     4796: 1076:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
     4796: 1077:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
     4796: 1078:	state->deckCount[nextPlayer]--;
        -: 1079:      }    
        -: 1080:		       
     4797: 1081:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 taken 584 (fallthrough)
branch  1 taken 4213
      584: 1082:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
      584: 1083:	state->playedCardCount++;
      584: 1084:	tributeRevealedCards[1] = -1;
        -: 1085:      }
        -: 1086:
    19188: 1087:      for (i = 0; i <= 2; i ++){
branch  0 taken 14391
branch  1 taken 4797 (fallthrough)
    14391: 1088:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 taken 12733 (fallthrough)
branch  1 taken 1658
branch  2 taken 12633 (fallthrough)
branch  3 taken 100
branch  4 taken 73 (fallthrough)
branch  5 taken 12560
     1831: 1089:	  state->coins += 2;
        -: 1090:	}
        -: 1091:		    
    12560: 1092:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 taken 11715 (fallthrough)
branch  1 taken 845
branch  2 taken 11685 (fallthrough)
branch  3 taken 30
branch  4 taken 11663 (fallthrough)
branch  5 taken 22
branch  6 taken 11356 (fallthrough)
branch  7 taken 307
branch  8 taken 221 (fallthrough)
branch  9 taken 11135
     1425: 1093:	  drawCard(currentPlayer, state);
call    0 returned 1425
     1425: 1094:	  drawCard(currentPlayer, state);
call    0 returned 1425
        -: 1095:	}
        -: 1096:	else{//Action Card
    11135: 1097:	  state->numActions = state->numActions + 2;
        -: 1098:	}
        -: 1099:      }
        -: 1100:	    
     4797: 1101:      return 0;
        -: 1102:		
     4210: 1103:    case ambassador:
     4210: 1104:      j = 0;		//used to check if player has enough cards to discard
        -: 1105:
     4210: 1106:      if (choice2 > 2 || choice2 < 0)
branch  0 taken 2236 (fallthrough)
branch  1 taken 1974
branch  2 taken 0 (fallthrough)
branch  3 taken 2236
        -: 1107:	{
     1974: 1108:	  return -1;				
        -: 1109:	}
        -: 1110:
     2236: 1111:      if (choice1 == handPos)
branch  0 taken 405 (fallthrough)
branch  1 taken 1831
        -: 1112:	{
      405: 1113:	  return -1;
        -: 1114:	}
        -: 1115:
    12240: 1116:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 10409
branch  1 taken 1831 (fallthrough)
        -: 1117:	{
    10409: 1118:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 taken 8578 (fallthrough)
branch  1 taken 1831
branch  2 taken 494 (fallthrough)
branch  3 taken 8084
branch  4 taken 371 (fallthrough)
branch  5 taken 123
        -: 1119:	    {
      371: 1120:	      j++;
        -: 1121:	    }
        -: 1122:	}
     1831: 1123:      if (j < choice2)
branch  0 taken 1105 (fallthrough)
branch  1 taken 726
        -: 1124:	{
     1105: 1125:	  return -1;				
        -: 1126:	}
        -: 1127:
        -: 1128:      if (DEBUG) 
        -: 1129:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1130:
        -: 1131:      //increase supply count for choosen card by amount being discarded
      726: 1132:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1133:			
        -: 1134:      //each other player gains a copy of revealed card
     2511: 1135:      for (i = 0; i < state->numPlayers; i++)
branch  0 taken 1785
branch  1 taken 726 (fallthrough)
        -: 1136:	{
     1785: 1137:	  if (i != currentPlayer)
branch  0 taken 1078 (fallthrough)
branch  1 taken 707
        -: 1138:	    {
     1078: 1139:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 returned 1078
        -: 1140:	    }
        -: 1141:	}
        -: 1142:
        -: 1143:      //discard played card from hand
      726: 1144:      discardCard(handPos, currentPlayer, state, 0);			
call    0 returned 726
        -: 1145:
        -: 1146:      //trash copies of cards returned to supply
      849: 1147:      for (j = 0; j < choice2; j++)
branch  0 taken 123
branch  1 taken 726 (fallthrough)
        -: 1148:	{
      278: 1149:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 268
branch  1 taken 10 (fallthrough)
        -: 1150:	    {
      268: 1151:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 taken 113 (fallthrough)
branch  1 taken 155
        -: 1152:		{
      113: 1153:		  discardCard(i, currentPlayer, state, 1);
call    0 returned 113
      113: 1154:		  break;
        -: 1155:		}
        -: 1156:	    }
        -: 1157:	}			
        -: 1158:
      726: 1159:      return 0;
        -: 1160:		
     3062: 1161:    case cutpurse:
        -: 1162:
     3062: 1163:      updateCoins(currentPlayer, state, 2);
call    0 returned 3062
    10636: 1164:      for (i = 0; i < state->numPlayers; i++)
branch  0 taken 7574
branch  1 taken 3062 (fallthrough)
        -: 1165:	{
     7574: 1166:	  if (i != currentPlayer)
branch  0 taken 4512 (fallthrough)
branch  1 taken 3062
        -: 1167:	    {
     4569: 1168:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 taken 78
branch  1 taken 4491 (fallthrough)
        -: 1169:		{
       78: 1170:		  if (state->hand[i][j] == copper)
branch  0 taken 21 (fallthrough)
branch  1 taken 57
        -: 1171:		    {
       21: 1172:		      discardCard(j, i, state, 0);
call    0 returned 21
       21: 1173:		      break;
        -: 1174:		    }
       57: 1175:		  if (j == state->handCount[i])
branch  0 taken 0 (fallthrough)
branch  1 taken 57
        -: 1176:		    {
    #####: 1177:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1178:			{
        -: 1179:			  if (DEBUG)
        -: 1180:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1181:			}	
    #####: 1182:		      break;
        -: 1183:		    }		
        -: 1184:		}
        -: 1185:					
        -: 1186:	    }
        -: 1187:				
        -: 1188:	}				
        -: 1189:
        -: 1190:      //discard played card from hand
     3062: 1191:      discardCard(handPos, currentPlayer, state, 0);			
call    0 returned 3062
        -: 1192:
     3062: 1193:      return 0;
        -: 1194:
        -: 1195:		
     3032: 1196:    case embargo: 
        -: 1197:      //+2 Coins
     3032: 1198:      state->coins = state->coins + 2;
        -: 1199:			
        -: 1200:      //see if selected pile is in play
     3032: 1201:      if ( state->supplyCount[choice1] == -1 )
branch  0 taken 44 (fallthrough)
branch  1 taken 2988
        -: 1202:	{
       44: 1203:	  return -1;
        -: 1204:	}
        -: 1205:			
        -: 1206:      //add embargo token to selected supply pile
     2988: 1207:      state->embargoTokens[choice1]++;
        -: 1208:			
        -: 1209:      //trash card
     2988: 1210:      discardCard(handPos, currentPlayer, state, 1);		
call    0 returned 2988
     2988: 1211:      return 0;
        -: 1212:		
     3038: 1213:    case outpost:
        -: 1214:      //set outpost flag
     3038: 1215:      state->outpostPlayed++;
        -: 1216:			
        -: 1217:      //discard card
     3038: 1218:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 3038
     3038: 1219:      return 0;
        -: 1220:		
     3191: 1221:    case salvager:
        -: 1222:      //+1 buy
     3191: 1223:      state->numBuys++;
        -: 1224:			
     3191: 1225:      if (choice1)
branch  0 taken 2632 (fallthrough)
branch  1 taken 559
        -: 1226:	{
        -: 1227:	  //gain coins equal to trashed card
     2632: 1228:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 returned 2632
call    1 returned 2632
        -: 1229:	  //trash card
     2632: 1230:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 returned 2632
        -: 1231:	}
        -: 1232:			
        -: 1233:      //discard card
     3191: 1234:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 3191
     3191: 1235:      return 0;
        -: 1236:		
     4112: 1237:    case sea_hag:
    14320: 1238:      for (i = 0; i < state->numPlayers; i++){
branch  0 taken 10208
branch  1 taken 4112 (fallthrough)
    10208: 1239:	if (i != currentPlayer){
branch  0 taken 6096 (fallthrough)
branch  1 taken 4112
        -: 1240:          //assert(state->deckCount[i] > 0);
        -: 1241:	  //assert(state->discardCount < MAX_DECK);
     6096: 1242:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
     6096: 1243:	  state->discardCount[i]++;
     6096: 1244:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1245:	}
        -: 1246:      }
     4112: 1247:      return 0;
        -: 1248:		
     3926: 1249:    case treasure_map:
        -: 1250:      //search hand for another treasure_map
     3926: 1251:      index = -1;
    25050: 1252:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 21630
branch  1 taken 3420 (fallthrough)
        -: 1253:	{
    21630: 1254:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 taken 4192 (fallthrough)
branch  1 taken 17438
branch  2 taken 506 (fallthrough)
branch  3 taken 3686
        -: 1255:	    {
      506: 1256:	      index = i;
      506: 1257:	      break;
        -: 1258:	    }
        -: 1259:	}
     3926: 1260:      if (index > -1)
branch  0 taken 506 (fallthrough)
branch  1 taken 3420
        -: 1261:	{
        -: 1262:	  //trash both treasure cards
      506: 1263:	  discardCard(handPos, currentPlayer, state, 1);
call    0 returned 506
      506: 1264:	  discardCard(index, currentPlayer, state, 1);
call    0 returned 506
        -: 1265:
        -: 1266:	  //gain 4 Gold cards
     2530: 1267:	  for (i = 0; i < 4; i++)
branch  0 taken 2024
branch  1 taken 506 (fallthrough)
        -: 1268:	    {
     2024: 1269:	      gainCard(gold, state, 1, currentPlayer);
call    0 returned 2024
        -: 1270:	    }
        -: 1271:				
        -: 1272:	  //return success
      506: 1273:	  return 1;
        -: 1274:	}
        -: 1275:			
        -: 1276:      //no second treasure_map found in hand
     3420: 1277:      return -1;
        -: 1278:    }
        -: 1279:	
    #####: 1280:  return -1;
        -: 1281:}
        -: 1282:
function discardCard called 47066 returned 100% blocks executed 100%
    47066: 1283:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1284:{
        -: 1285:	
        -: 1286:  //if card is not trashed, added to Played pile 
    47066: 1287:  if (trashFlag < 1)
branch  0 taken 33005 (fallthrough)
branch  1 taken 14061
        -: 1288:    {
        -: 1289:      //add card to played pile
    33005: 1290:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    33005: 1291:      state->playedCardCount++;
        -: 1292:    }
        -: 1293:	
        -: 1294:  //set played card to -1
    47066: 1295:  state->hand[currentPlayer][handPos] = -1;
        -: 1296:	
        -: 1297:  //remove card from player's hand
    47066: 1298:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 6604 (fallthrough)
branch  1 taken 40462
        -: 1299:    {
        -: 1300:      //reduce number of cards in hand
     6604: 1301:      state->handCount[currentPlayer]--;
        -: 1302:    }
    40462: 1303:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 392 (fallthrough)
branch  1 taken 40070
        -: 1304:    {
        -: 1305:      //reduce number of cards in hand
      392: 1306:      state->handCount[currentPlayer]--;
        -: 1307:    }
        -: 1308:  else 	
        -: 1309:    {
        -: 1310:      //replace discarded card with last card in hand
    40070: 1311:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1312:      //set last card to -1
    40070: 1313:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1314:      //reduce number of cards in hand
    40070: 1315:      state->handCount[currentPlayer]--;
        -: 1316:    }
        -: 1317:	
    47066: 1318:  return 0;
        -: 1319:}
        -: 1320:
function gainCard called 38861 returned 100% blocks executed 100%
    38861: 1321:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1322:{
        -: 1323:  //Note: supplyPos is enum of choosen card
        -: 1324:	
        -: 1325:  //check if supply pile is empty (0) or card is not used in game (-1)
    38861: 1326:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 38861
branch  1 taken 281 (fallthrough)
branch  2 taken 38580
        -: 1327:    {
      281: 1328:      return -1;
        -: 1329:    }
        -: 1330:	
        -: 1331:  //added card for [whoseTurn] current player:
        -: 1332:  // toFlag = 0 : add to discard
        -: 1333:  // toFlag = 1 : add to deck
        -: 1334:  // toFlag = 2 : add to hand
        -: 1335:
    38580: 1336:  if (toFlag == 1)
branch  0 taken 2024 (fallthrough)
branch  1 taken 36556
        -: 1337:    {
        -: 1338:      //assert(state->deckCount[player] < MAX_DECK);
     2024: 1339:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
     2024: 1340:      state->deckCount[player]++;
        -: 1341:    }
    36556: 1342:  else if (toFlag == 2)
branch  0 taken 55 (fallthrough)
branch  1 taken 36501
        -: 1343:    {
       55: 1344:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
       55: 1345:      state->handCount[player]++;
        -: 1346:    }
        -: 1347:  else
        -: 1348:    {
        -: 1349:      //assert(state->discardCount[player] < MAX_DECK);
    36501: 1350:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    36501: 1351:      state->discardCount[player]++;
        -: 1352:    }
        -: 1353:	
        -: 1354:  //decrease number in supply pile
    38580: 1355:  state->supplyCount[supplyPos]--;
        -: 1356:	 
    38580: 1357:  return 0;
        -: 1358:}
        -: 1359:
function updateCoins called 264425 returned 100% blocks executed 100%
   264425: 1360:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1361:{
        -: 1362:  int i;
        -: 1363:	
        -: 1364:  //reset coin count
   264425: 1365:  state->coins = 0;
        -: 1366:
        -: 1367:  //add coins for each Treasure card in player's hand
  1638790: 1368:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 1374365
branch  1 taken 264425 (fallthrough)
        -: 1369:    {
  1374365: 1370:      if (state->hand[player][i] == copper)
branch  0 taken 340900 (fallthrough)
branch  1 taken 1033465
        -: 1371:	{
   340900: 1372:	  state->coins += 1;
        -: 1373:	}
  1033465: 1374:      else if (state->hand[player][i] == silver)
branch  0 taken 11488 (fallthrough)
branch  1 taken 1021977
        -: 1375:	{
    11488: 1376:	  state->coins += 2;
        -: 1377:	}
  1021977: 1378:      else if (state->hand[player][i] == gold)
branch  0 taken 7325 (fallthrough)
branch  1 taken 1014652
        -: 1379:	{
     7325: 1380:	  state->coins += 3;
        -: 1381:	}	
        -: 1382:    }	
        -: 1383:
        -: 1384:  //add bonus
   264425: 1385:  state->coins += bonus;
        -: 1386:
   264425: 1387:  return 0;
        -: 1388:}
        -: 1389:
        -: 1390:
        -: 1391://end of dominion.c
        -: 1392:
